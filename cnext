#!/usr/bin/env perl

package main;

our $SOURCE_CODE;

BEGIN {    # thanks to mst and shadowcat to read itself
    if ( grep { m{self-?install} } @ARGV ) {
        require Filter::Util::Call;    #  CORE from 5.8

        $SOURCE_CODE = qq[#!$^X\n\n];  # set the shebang

        Filter::Util::Call::filter_add(
            sub {
                Filter::Util::Call::filter_del();
                1 while Filter::Util::Call::filter_read();
                $SOURCE_CODE .= $_;
                return 1;
            }
        );
    }
}

BEGIN {
    if ( "$]" < 5.019 ) {    # needs 5.20 for function signature
        die <<"EOS";
$0 is not supported on Perl $]
	cnext needs Perl 5.20 or higher
	please consider alternate solutions such as App::cpanminus or App::cpm
EOS
    }
}

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
    my %fatpacked;

    $fatpacked{"App/cnext.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT';
  package App::cnext;use App::cnext::std;our$VERSION="0.0001";our$REVISION='6251786';sub source {state$branch="$]" > 7 ? 'p7' : 'p5';return$branch}1;
APP_CNEXT

    $fatpacked{"App/cnext/BUILD.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_BUILD';
  package App::cnext::BUILD;use App::cnext;use App::cnext::std;use App::cnext::Logger;use App::cnext::Helpers qw{read_file write_file};use Cwd ();use File::Basename ();use constant IN_JSON=>qw{abstract builder builder_API_version license maintainers name no_index primary provides recommends_runtime requires_build requires_develop requires_runtime scripts source version tests xs};use Simple::Accessor +IN_JSON,qw{_rootdir _filepath};with 'App::cnext::Roles::JSON';sub build ( $self, %options ) {$self->builder_API_version($self->builder_API_version);$self->builder(lc($options{builder}// $self->builder));if (!defined$self->name ||!length$self->name){ERROR("missing name");return}if (!defined$self->version){ERROR("missing version for " .$self->name);return}return$self}sub _build_xs {0}sub _build_builder {'play'}sub _build_builder_API_version {1}sub _build_license {'perl'}sub _build_source {App::cnext::source()}sub _build_version {'0.001'}sub _build_tests {['t/*.t']}sub _build_maintainers {[]}sub _build_provides {{}}sub _build_recommends_runtime {{}}sub _build_requires_build {{}}sub _build_requires_develop {{}}sub _build_requires_runtime {{}}sub _build_scripts {[]}sub bin($self) {return$self->scripts}sub _validate_builder ( $self, $v ) {return 1 if$v && $v =~ m{^(?:play|makefile\.pl|build\.pl)$};die 'Invalid builder ' .($v // 'undef')}sub _validate_builder_API_version ( $self, $v ) {return 1 if$v && $v==1;die "Invalid builder_API_version " .($v // 'undef');return}sub save_to_file ( $self, $file = 'BUILD.json' ) {my$json=$self->json->pretty(1)->encode($self->as_hash);return eval {write_file($file,$json);1}}sub as_hash($self) {for my$attr (IN_JSON){$self->can($attr)->($self)}my%as_hash=map {$_=>$self->{$_}}IN_JSON;if ($as_hash{tests}&& scalar @{$as_hash{tests}}==1 && $as_hash{tests}->[0]eq 't/*.t'){delete$as_hash{tests}}delete$as_hash{no_index}unless defined$as_hash{no_index};return \%as_hash}sub create_from_file($file='BUILD.json') {state$JSON=App::cnext::Roles::JSON->new;$file=Cwd::abs_path($file);my$json;if (-e $file){eval {$json=$JSON->json->decode(read_file($file,':utf8'));1}or eval {$json=$JSON->json->decode(read_file($file,''));1}or DEBUG("Fail to read $file $@")}else {ERROR("Missing file $file");return}if (!ref$json){ERROR("Fail to read BUILD.json file $file");return}my$_rootdir=File::Basename::dirname($file);return App::cnext::BUILD->new(%$json,_rootdir=>$_rootdir,_filepath=>$file)}1;
APP_CNEXT_BUILD

    $fatpacked{"App/cnext/Helpers.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_HELPERS';
  package App::cnext::Helpers;use App::cnext::std;use Config;use File::Which ();use App::cnext::Logger;use Exporter 'import';our@EXPORT_OK=qw(read_file zip write_file is_fatpacked update_shebang is_valid_distribution_name);sub read_file ( $file, $mode = ':utf8' ) {local $/;open(my$fh,'<' .$mode,$file)or die "Fail to open file: $! " .join(' ',(caller(1))[0,1,2,3 ])."\n";return readline($fh)}sub is_fatpacked() {return unless my$ref=ref$INC{'App/cnext/cmd/selfinstall.pm'};return$ref =~ m{^FatPacked} ? 1 : 0}sub write_file ( $file, $content, $mode = ':utf8' ) {open(my$fh,'>' .$mode,$file)or die "Fail to open file: '$file' $! " .join(' ',(caller(1))[0,1,2,3 ])."\n";print {$fh}$content;return}sub zip : prototype(\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {my$max=-1;$max < $#$_ && ($max=$#$_)foreach @_;map {my$ix=$_;map $_->[$ix],@_}0 .. $max}sub make_binary {my@lookup=($Config{make},qw{make gmake});for my$bin (@lookup){next unless$bin;my$path=File::Which::which($Config{make});next unless -x $path;no warnings 'redefine';*make_binary=sub {$path};return$path}FATAL("Cannot find make binary")}sub is_valid_distribution_name($name) {return defined$name && $name =~ /^[a-z0-9+_-]+$/is}sub prove_binary {my$prove;my@prefixes=qw{bin installbin sitebin vendorbin};for my$prefix (@prefixes){next unless$Config{$prefix};$prove=$Config{$prefix}.'/prove';last if -x $prove}if (!-x $prove){my$perldoc=$^X ."doc";$prove=qx{$perldoc -l prove};$prove=undef if $?!=0}if (defined$prove && -x $prove){no warnings 'redefine';*prove_binary=sub {$prove};return$prove}FATAL("Cannot find 'prove' binary")}sub update_shebang($file) {return unless defined$file && -f $file;open(my$input,'<',$file)or die "Fail to open file: $! " .join(' ',(caller(1))[0,1,2,3 ])."\n";my$output_file="$file.tmp";open(my$output,'>',$output_file)or die "Fail to open file: $! " .join(' ',(caller(1))[0,1,2,3 ])."\n";my$c=0;while (my$line=<$input>){if (++$c==1 && $line =~ m{^#!.*perl}){$line=qq[#!$^X]}print {$output}$line}return}1;
APP_CNEXT_HELPERS

    $fatpacked{"App/cnext/Http.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_HTTP';
  package App::cnext::Http;use App::cnext::std;use App::cnext ();use HTTP::Tinyish;sub create ( $class, %args ) {my@try=$args{prefer}? @{$args{prefer}}: qw(HTTPTiny LWP Curl Wget);my ($backend,$tool,$desc);for my$try (map "HTTP::Tinyish::$_",@try){my$meta=HTTP::Tinyish->configure_backend($try)or next;$try->supports("https")or next;($tool)=sort keys %$meta;($desc=$meta->{$tool})=~ s/^(.*?)\n.*/$1/s;$backend=$try,last}die "Couldn't find HTTP Clients that support https" unless$backend;my$http=$backend->new(agent=>"App::cnext/v" .$App::cnext::VERSION,timeout=>60,verify_SSL=>1,%args,);my$keep_alive=exists$args{keep_alive}? $args{keep_alive}: 1;if ($keep_alive and $backend =~ /LWP$/){$http->{ua}->conn_cache({total_capacity=>1 })}return$http}1;
APP_CNEXT_HTTP

    $fatpacked{"App/cnext/IPC.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_IPC';
  package App::cnext::IPC;use App::cnext::std;use App::cnext::Logger qw{RUN DEBUG STDERROR};use IPC::Run3 ();sub run3 ( $cmd, $log_level = 'DEBUG' ) {my ($out,$err);{my$oneliner=ref$cmd ? join(' ',@$cmd): $cmd;RUN($oneliner)}IPC::Run3::run3($cmd,\undef,_output(\$out,$log_level),_error(\$err));return ($?,$out,$err)}sub _output ( $r_str, $log_level = 'DEBUG' ) {my$log=App::cnext::Logger->can($log_level)or die "unknown log level '$log_level'";return sub($line) {$log->($line);$$r_str='' unless defined $$r_str;$$r_str .= $line;return}}sub _error($r_str) {return sub($line) {STDERROR($line);$$r_str='' unless defined $$r_str;$$r_str .= $line;return}}1;
APP_CNEXT_IPC

    $fatpacked{"App/cnext/Index.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INDEX';
  package App::cnext::Index;use App::cnext::std;use App::cnext::Helpers qw{read_file zip};sub _build_cache($self) {return$self->json->decode(read_file($self->file))}sub iterate ( $self, $callback ) {die "Missing a callback function" unless ref$callback eq 'CODE';open(my$fh,'<:utf8',$self->file)or die $!;my$in_data;while (my$line=<$fh>){if (!$in_data){$in_data=1 if$line =~ m{^\s*"data"};next}next unless$line =~ m{^\s*\[};$line =~ s{,\s*$}{};my$raw;eval {$raw=$self->json->decode($line)};my$last=$callback->($raw);last if$last}return}sub raw_to_hash ( $self, $raw ) {return {zip(@{$self->sorted_columns},@$raw)}}1;
APP_CNEXT_INDEX

    $fatpacked{"App/cnext/Index/Modules.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INDEX_MODULES';
  package App::cnext::Index::Modules;use App::cnext::std;use App::cnext::Indexes;use App::cnext::Logger;use base 'App::cnext::Index';use App::cnext::Search::Result ();use Simple::Accessor qw{file cli};with 'App::cnext::Roles::JSON';with 'App::cnext::Index::Role::Columns';sub build ( $self, %opts ) {$self->{file}=App::cnext::Indexes::get_modules_ix_file($self->cli);return$self}sub search ( $self, $module, $version = undef ) {FATAL("Missing module")unless defined$module;INFO("search module $module");my$ix=$self->columns->{module};my$result;my$iterator=sub($raw) {return unless$raw->[$ix]eq $module;if (defined$version){my$v_ix=$self->columns->{version};if ($raw->[$v_ix]ne $version){DEBUG("requested $module version $version ; latest is " .$raw->[$v_ix]);return}}$result=$self->raw_to_hash($raw);return 1};$self->iterate($iterator);return$result}sub regexp_search ( $self, $pattern ) {return unless defined$pattern && length$pattern;my$result=App::cnext::Search::Result->new;my$module_ix=$self->columns->{module};my$repository_ix=$self->columns->{repository};my$iterator=sub($raw) {if ($raw->[$module_ix]=~ m{$pattern}i){$result->add_module($raw->[$module_ix])}if ($raw->[$repository_ix]=~ m{$pattern}i){$result->add_repository($raw->[$repository_ix])}return};$self->iterate($iterator);return$result}1;
APP_CNEXT_INDEX_MODULES

    $fatpacked{"App/cnext/Index/Repositories.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INDEX_REPOSITORIES';
  package App::cnext::Index::Repositories;use App::cnext::std;use App::cnext::Indexes;use App::cnext::Logger;use base 'App::cnext::Index';use Simple::Accessor qw{file cli};with 'App::cnext::Roles::JSON';with 'App::cnext::Index::Role::Columns';with 'App::cnext::Index::Role::TemplateURL';sub build ( $self, %opts ) {$self->{file}=App::cnext::Indexes::get_repositories_ix_file($self->cli);return$self}sub search ( $self, $repository, $version = undef ) {INFO("search repository $repository / " .($version // 'undef'));my$repository_ix=$self->columns->{repository};my$version_ix=$self->columns->{version};my$result;my$iterator=sub($raw) {return unless$raw->[$repository_ix]eq $repository;if (!defined$version || $version eq $raw->[$version_ix]){$result=$self->raw_to_hash($raw);return 1}return};$self->iterate($iterator);return$result}sub get_tarball_url ( $self, $repository ) {die unless ref$repository;my$url=$self->template_url;$url =~ s{:([a-z0-9]+)}{$repository->{$1}}g;return$url}sub get_git_repository_url ( $self, $repository ) {die unless ref$repository;my$url=$self->template_url;($url,undef)=split('/archive',$url);$url .= '.git';$url =~ s{:([a-z0-9]+)}{$repository->{$1}}g;return$url}1;
APP_CNEXT_INDEX_REPOSITORIES

    $fatpacked{"App/cnext/Index/Role/Columns.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INDEX_ROLE_COLUMNS';
  package App::cnext::Index::Role::Columns;use App::cnext::std;use App::cnext::Logger;use Simple::Accessor qw{columns sorted_columns};sub _build_columns($self) {open(my$fh,'<:utf8',$self->file)or die "Cannot open ExplicitVersions files: $!";my$columns={};my$ix=0;my$description;while (my$line=<$fh>){next unless$line =~ m{^\s*"columns"};$line =~ s{,\s*$}{};$line="{ $line }";eval {$description=$self->json->decode($line)};last}if (!$description ||!$description->{columns}){FATAL("Cannot read columns definition for ExplicitVersions index file")}for my$name (@{$description->{columns}}){$columns->{$name}=$ix++}return$columns}sub _build_sorted_columns($self) {my$columns=$self->columns;my$sorted=[];for my$k (keys %$columns){$sorted->[$columns->{$k}]=$k}return$sorted}1;
APP_CNEXT_INDEX_ROLE_COLUMNS

    $fatpacked{"App/cnext/Index/Role/TemplateURL.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INDEX_ROLE_TEMPLATEURL';
  package App::cnext::Index::Role::TemplateURL;use App::cnext::std;use App::cnext::Logger;use File::Basename qw(basename);use Simple::Accessor qw{template_url};sub _build_template_url($self) {FATAL("'file' is not defined")unless defined$self->file && length$self->file;my$basename=basename($self->file);open(my$fh,'<:utf8',$self->file)or die "Cannot open $basename: $!";my$columns={};my$ix=0;my$description;while (my$line=<$fh>){next unless$line =~ m{^\s*"template_url"};if ($line =~ m{"template_url"\s*:\s*["'](.+)["']\s*,}){return $1}last}FATAL("Cannot read template_url from $basename");return}1;
APP_CNEXT_INDEX_ROLE_TEMPLATEURL

    $fatpacked{"App/cnext/Indexes.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INDEXES';
  package App::cnext::Indexes;use App::cnext;use App::cnext::std;use App::cnext::Logger;use App::cnext::Installer::Unpacker ();use constant BASE_URL=>q[https://github.com/next-cpan/next-indexes];use constant IDX_TARBALL_URL=>BASE_URL .q[/archive/] .App::cnext::source().q[.tar.gz];use constant MODULES_IX_BASENAME=>'modules.idx';use constant REPOSITORIES_IX_BASENAME=>'repositories.idx';use constant REFRESH_TIMEOUT=>24 * 3_600;my$_MODULES_IX_FILE;my$_REPOSITORIES_IX_FILE;sub setup_once ( $cli, $attempt = 1 ) {no warnings 'redefine';ref$cli eq 'App::cnext::cli' or die "cli is not one App::cnext: $cli";my$root=$cli->cache_dir;$_MODULES_IX_FILE="$root/" .MODULES_IX_BASENAME;$_REPOSITORIES_IX_FILE="$root/" .REPOSITORIES_IX_BASENAME;my@all_ix_files_basename=(MODULES_IX_BASENAME,REPOSITORIES_IX_BASENAME);my@all_ix_files=($_MODULES_IX_FILE,$_REPOSITORIES_IX_FILE);my$now=time;INFO("Check and refresh cnext index files.");my$force_refresh=$cli->refresh;if (!$force_refresh){for my$file (@all_ix_files){if (!-e $file){$force_refresh=1;last}my$mtime=(stat($file))[9];if (($now - $mtime)> REFRESH_TIMEOUT){DEBUG("clearing index file $file");unlink($file);$force_refresh=1}}}if ($force_refresh){my$http=$cli->http;my$ix_tarball=$cli->cache_dir .'/' .App::cnext::source().'.tar.gz';unlink$ix_tarball if$attempt > 1;App::cnext::Logger::fetch(IDX_TARBALL_URL);$http->mirror(IDX_TARBALL_URL,$ix_tarball);my$unpacker=App::cnext::Installer::Unpacker->new(tmproot=>$cli->build_dir);my$cd=$cli->cache_dir;my$relative_path=$unpacker->unpack($ix_tarball);FATAL("Fail to extra index tarball: " .IDX_TARBALL_URL)unless defined$relative_path;require File::Copy;for my$f (@all_ix_files_basename){my$tmp=$cli->build_dir .'/' .$relative_path .'/' .$f;FATAL("File '$f' is not part of tarball " .IDX_TARBALL_URL)unless -f $tmp;File::Copy::move($tmp,"$root/$f")or FATAL("Fail to move index file '$f' to '$root/$f'")}}if (!_check_file_versions(@all_ix_files)){if ($attempt >= 2){FATAL("index files versions mismatch")}else {map {unlink $_}@all_ix_files;return setup_once($cli,$attempt + 1)}}*setup_once=sub {};return}sub _check_file_versions(@files) {FATAL("Need at least two files")if scalar@files < 2;my$use_version;for my$file (@files){if (open(my$fh,'<:utf8',$file)){my$has_version;while (my$line=<$fh>){if ($line =~ m{"version"\s*:\s*(\w+)\s*,}){$has_version=1;my$v=$1;if (!defined$use_version){$use_version=$v}elsif ($v ne $use_version){WARN("file version mismatch: $file");return}last}}FATAL(qq[Cannot find "version" in index file: $file])unless$has_version}}return 1}sub get_modules_ix_file($cli) {setup_once($cli);return$_MODULES_IX_FILE}sub get_repositories_ix_file($cli) {setup_once($cli);return$_REPOSITORIES_IX_FILE}1;
APP_CNEXT_INDEXES

    $fatpacked{"App/cnext/InstallDirs.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INSTALLDIRS';
  package App::cnext::InstallDirs;use App::cnext::std;use App::cnext::Logger;use App::cnext::IPC;use Config;use File::Path;use File::Spec;use Umask::Local ();use Simple::Accessor qw{type arch lib bin script man1 man3};my$IX={arch=>0,lib=>1,bin=>2,script=>3,man1=>4,man3=>5 };my$MAP={perl=>[qw{installarchlib installprivlib installbin installscript installman1dir installman3dir} ],site=>[qw{installsitearch installsitelib installsitebin installsitescript installsiteman1dir installsiteman3dir} ],vendor=>[qw{installvendorarch installvendorlib installvendorbin installvendorscript installvendorman1dir installvendorman3dir} ],};sub _get_config {return \%Config}sub build ( $self, %options ) {my$type=delete$options{type}// 'site';$self->type($type);if (scalar keys%options){die q[Too many arguments to new: ] .join(', ',sort keys%options)}my$cfg=_get_config();for my$k (keys %$IX){my$name=$MAP->{$type}->[$IX->{$k}];$self->{$k}=$cfg->{$name}}return$self}sub _validate_type ( $self, $v ) {return 1 if defined$v && defined$MAP->{$v};FATAL('Invalid type ' .($v // 'undef'))}sub create_if_missing ( $self, $dir ) {FATAL("dir is not defined")unless defined$dir && length$dir;return 2 if -d $dir;DEBUG("Creating missing directory: $dir");File::Path::make_path($dir,{chmod=>0755,verbose=>0 })or FATAL("Fail to create $dir");return 1}sub adjust_perl_shebang ( $self, $file, $perl = $^X ) {my$shebang;open(my$input,'<',$file)or do {WARN("Fail to open $file");return};$shebang=readline$input;chomp$shebang if defined$shebang;my$original_shebang=$shebang;return unless$shebang =~ s{^#![/\w\.\-_]*\s*perl\s*$}{#!$perl} || $shebang =~ s{^#![/\w\.]*\s*perl\s+(-.*)$}{#!$perl $1};return if$original_shebang eq $shebang;my$content;{local $/;$content=readline$input}close$input;open(my$output,'>',$file)or do {WARN("Fail to open $file for writing");return};print {$output}$shebang ."\n";print {$output}$content;close$output;return 1}sub install_to_bin ( $self, $file, $basename = undef, $perl = $^X ) {FATAL("File is not defined")unless defined$file && length$file;FATAL("Cannot find file $file")unless -f $file;$basename //= File::Basename::basename($file);my$to_file=File::Spec->catfile($self->bin,$basename);$self->install_file($file,$to_file,0755);$self->adjust_perl_shebang($to_file,$perl)and DEBUG("perl shebang adjusted for '$file' to use $perl");App::cnext::IPC::run3(['chmod','+x',$to_file ])unless -x $to_file;return$to_file}sub install_to_lib ( $self, $from_file, $to_file ) {if ($to_file =~ m{^/}){FATAL("to_file cannot start with a '/', need a relative path: $to_file")}return$self->install_file($from_file,File::Spec->catfile($self->lib,$to_file))}sub install_file ( $self, $from_file, $to_file, $perms = undef ) {if ($to_file =~ m{/$}){FATAL("to_file cannot be a folder name, path should not end by '/': $to_file")}if (-d $to_file){FATAL("Cannot install file, a directory already exists: $to_file")}my$destination_directory=File::Basename::dirname($to_file);$self->create_if_missing($destination_directory);my$umask;$umask=Umask::Local->new($perms ^ 07777)if defined$perms;DEBUG("cp $from_file $to_file");File::Copy::copy($from_file,$to_file);if (!-f $to_file){FATAL("Failed to copy file $to_file")}if (-s _!=-s $from_file){unlink($to_file)or FATAL("Failed to update file $to_file - $!");File::Copy::copy($from_file,$to_file);if (!-f $to_file && -s _!=-s $from_file){FATAL("Failed to copy file $from_file / $to_file [size mismatch]")}}return}1;
APP_CNEXT_INSTALLDIRS

    $fatpacked{"App/cnext/Installer.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INSTALLER';
  package App::cnext::Installer;use App::cnext::std;use App::cnext;use App::cnext::Logger;use App::cnext::Module ();use App::cnext::Signature qw{check_signature};use App::cnext::Installer::Unpacker ();use App::cnext::IPC ();use App::cnext::BUILD ();use App::cnext::Installer::Command ();use App::cnext::Installer::Share ();use App::cnext::Helpers qw{is_valid_distribution_name};use Config;use File::Copy ();use File::Path ();use File::Find ();use File::Basename ();use Umask::Local;use File::pushd;use App::cnext::InstallDirs ();App::cnext::Logger->import(qw{fetch configure install resolve});use Simple::Accessor qw{cli unpacker BUILD depth local_lib_bin local_lib_lib installdirs run_install};use constant EXTUTILS_MAKEMAKER_MIN_VERSION=>'6.64';sub build ( $self, %opts ) {$self->{_tracked_modules}={};$self->{_tracked_repositories}={};$self->{depth}=0;$self->{run_install}//= 1;$self->{BUILD}={};return$self}sub _build_installdirs($self) {App::cnext::InstallDirs->new(type=>$self->cli->installdirs)}sub _build_unpacker($self) {App::cnext::Installer::Unpacker->new(tmproot=>$self->cli->build_dir)}sub has_module_version ( $self, $module, $version ) {if ($self->depth==1 && $self->cli->reinstall){DEBUG("(re)installing module $module");return}if ($self->cli->local_lib){return 1 if App::cnext::Module::has_module_version($module,$version,$self->cli->local_lib);if ($self->depth > 1){return 1 if App::cnext::Module::has_module_version($module,$version)}}else {return App::cnext::Module::has_module_version($module,$version)}return}sub install_from_file ( $self, $file = 'BUILD.json' ) {return unless my$BUILD=App::cnext::BUILD::create_from_file($file);$self->depth(1);my$ok=$self->install_from_BUILD($BUILD);$self->depth(0);return$ok}sub install_single_module ( $self, $module, $need_version = undef ) {return$self->install_single_module_or_repository($module,0,$need_version)}sub install_single_module_or_repository ( $self, $module_or_repository, $can_be_repo = 1, $need_version = undef ) {$self->depth($self->depth + 1);my$ok;if (defined$need_version){$ok=$self->has_module_version($module_or_repository,$need_version);DEBUG("Module $module_or_repository v$need_version is missing")unless$ok;if ($ok && ($self->depth==1 || $self->cli->verbose)){my$log_level=$self->depth > 1 ? q[resolve] : q[OK];my$logger=App::cnext::Logger->can($log_level);$logger->("$module_or_repository is already installed.")}}if (!$ok){$ok=$self->_install_single_module_or_repository($module_or_repository,$can_be_repo);my$msg=$ok ? "install of $module_or_repository succeeded" : "install of $module_or_repository failed";DEBUG($msg);if ($ok &&!$can_be_repo && defined$need_version){$ok=$self->has_module_version($module_or_repository,$need_version);DEBUG("Module $module_or_repository v$need_version is missing")unless$ok}}$self->depth($self->depth - 1);return$ok}sub _install_single_module_or_repository ( $self, $module_or_repository, $can_be_repo = 1 ) {return 1 if$self->tracking_module($module_or_repository);my$cli=$self->cli or die;my$name_as_column_char=index($module_or_repository,':')==-1 ? 0 : 1;my$custom_requested_version;if ($module_or_repository =~ s{\@(.+)$}{}){$custom_requested_version=$1;if ($name_as_column_char){$module_or_repository =~ s{::}{-}g;FAIL("Cannot request a specific version for a module: try $module_or_repository\@$custom_requested_version");return}}my$module_info;my$repository_info;if (!defined$custom_requested_version){$module_info=$cli->modules_idx->search($module_or_repository,$custom_requested_version)}if (!$module_info &&!$name_as_column_char && $can_be_repo){$repository_info=$cli->repositories_idx->search($module_or_repository,$custom_requested_version)}if (!$module_info &&!$repository_info && defined$custom_requested_version){my$repository=$module_or_repository;FATAL("Invalid distribution name: '$repository'")unless is_valid_distribution_name($repository);DEBUG("Try to install '$repository' from a custom tag/version.");my$branch=App::cnext::source();my$tag;if ($custom_requested_version =~ m{^$branch}){$tag=$custom_requested_version}elsif ($custom_requested_version =~ m{^v}){$tag=$branch .'-' .$custom_requested_version}elsif ($custom_requested_version =~ m{^[0-9\._]+$}){$tag=$branch .'-v' .$custom_requested_version}else {$tag=$custom_requested_version}my$version=0;if ($tag =~ m{^$branch-v(.+)$}){$version=$1}DEBUG("$repository: tag $tag ; version $version");$repository_info={repository=>$repository,version=>$version,sha=>$tag,signature=>undef,}}if (!$module_info &&!$repository_info){FAIL("Cannot find module or distribution '$module_or_repository'");return}if ($module_info){if ($self->has_module_version($module_info->{module},$module_info->{version})){my ($m,$v)=($module_info->{module},$module_info->{version});OK("$m is up to date. ($v)");return 1}$repository_info //= $cli->repositories_idx->search($module_info->{repository},$module_info->{repository_version})}if (!$repository_info){FAIL("Cannot find repository for " .$module_info->{repository});return}return$self->install_repository($repository_info)}sub install_repository ( $self, $repository_info ) {die unless ref$repository_info;my$name=$repository_info->{repository};return 1 if$self->tracking_repository($name);INFO("Installing Distribution $name");return unless$self->setup_tarball($repository_info);my$BUILD=$self->BUILD->{$name}or FATAL("Cannot find a BUILD entry for $name");my$version=$BUILD->version;if (my$primary=$BUILD->primary){my$module_v=$BUILD->provides->{$primary}->{version};if ($self->has_module_version($primary,$module_v)){OK("$name-$version is up to date.");return 1}}return$self->install_from_BUILD($BUILD,$name)}sub install_from_BUILD ( $self, $BUILD, $name = undef ) {if (!defined$name){$name=$BUILD->name;$self->BUILD->{$name}=$BUILD}my$version=$BUILD->version;return unless$self->resolve_dependencies($name);my$indir=pushd($BUILD->_rootdir);$self->_setup_local_lib_env();my$builder_type=$BUILD->builder;if ($builder_type eq 'play'){return unless$self->_builder_play($name)}elsif ($builder_type eq 'makefile.pl'){return unless$self->_builder_Makefile_PL($name)}elsif ($builder_type eq 'build.pl'){return unless$self->_builder_Build($name)}else {FATAL("Unknown builder type '$builder_type' for distribution '$name'")}$self->advertise_installed_modules($BUILD);if ($self->run_install){OK("Installed distribution $name-$version")}else {OK("Tests Succeeds for $name-$version")}return 1}sub advertise_installed_modules ( $self, $BUILD ) {return unless ref$BUILD && ref$BUILD->provides;for my$module (sort keys %{$BUILD->provides}){my$v=$BUILD->provides->{$module}->{version}// 0;DEBUG("advertise_installed_modules: $module => $v");App::cnext::Module::module_updated($module,$v,$self->cli->local_lib)}return}sub _setup_local_lib_env ( $self, $force = 0 ) {state$done;return if$done &&!$force;$done=1;return unless my$local_lib=$self->cli->local_lib;INFO("Using local-lib: $local_lib");require Cwd;require local::lib;my$ll=local::lib->new(quiet=>1)->activate($local_lib);$ll->setup_local_lib;$ll->setup_env_hash;$self->local_lib_bin($ll->bins->[0]);$self->local_lib_lib($ll->libs->[0]);$ENV{PERL_MM_OPT}.= " INSTALLMAN1DIR=none INSTALLMAN3DIR=none";$ENV{PERL_MM_USE_DEFAULT}=1;return}sub _builder_play ( $self, $name ) {my$BUILD=$self->BUILD->{$name}or die;if ($self->cli->run_tests){my@tests=('t/*.t');if (defined$BUILD->tests && ref$BUILD->tests eq 'ARRAY' && scalar @{$BUILD->tests}){@tests=@{$BUILD->tests}}{File::Path::make_path('blib/lib');File::Path::make_path('blib/arch')}my$cmd=App::cnext::Installer::Command->new(log_level=>'test',txt=>"tests for $name",cmd=>[$^X,"-MExtUtils::Command::MM","-MTest::Harness","-e","undef *Test::Harness::Switches; test_harness(0,lib)",@tests ],env=>{PERL_DL_NONLAZY=>1,AUTHOR_TESTING=>0,RELEASE_TESTING=>0,},timeout=>$self->cli->test_timeout,);my$tests_ok=$cmd->run();File::Path::rmtree('blib');return unless$tests_ok}if ($self->run_install){my$ok;my$install=sub {$ok=$self->_builder_play_install_files($BUILD)// 0;$ok &= $self->_builder_play_install_bin($BUILD)// 0;$ok &= $self->_builder_play_install_share($BUILD)// 0;return};App::cnext::Timeout->new(message=>q[Reach timeout while installing files],timeout=>$self->cli->install_timeout,)->run($install);return unless$ok}return 1}sub _builder_play_install_bin ( $self, $BUILD ) {die "invalid BUILD" unless ref$BUILD eq 'App::cnext::BUILD';my$scripts=$BUILD->scripts;return 1 unless ref$scripts && scalar @$scripts;if (my$local_lib_bin=$self->local_lib_bin){INFO("installing bin to local_lib $local_lib_bin");$self->installdirs->bin($local_lib_bin)}for my$script (@$scripts){DEBUG("installing $script");$self->installdirs->install_to_bin($script)}return 1}sub _builder_play_install_share ( $self, $BUILD ) {die "invalid BUILD" unless ref$BUILD eq 'App::cnext::BUILD';return 1 unless -d q[share] || -d q[share-module];return App::cnext::Installer::Share->new(installdirs=>$self->installdirs,BUILD=>$BUILD,)->install}sub _builder_play_install_files ( $self, $BUILD ) {my$inst_lib=$self->installdirs->lib;unless (defined$inst_lib && length$inst_lib){FATAL("install lib is not defined for " .$self->cli->installdirs ."\n")}if (!-d $inst_lib){DEBUG("Creating missing directory: $inst_lib");File::Path::make_path($inst_lib,{chmod=>0755,verbose=>0 })or FATAL("Fail to create $inst_lib")}FATAL("inst_lib is missing: $inst_lib")unless -d $inst_lib;if (my$local_lib_lib=$self->local_lib_lib){INFO("installing to local_lib $local_lib_lib");$inst_lib=$local_lib_lib;$self->installdirs->lib($local_lib_lib)}my$has_errors=0;my$wanted=sub {return unless -f $File::Find::name;my$destination=$File::Find::name;$destination =~ s{^lib/}{};eval {$self->installdirs->install_to_lib($File::Find::name,$destination);1}or ++$has_errors;return};my$umask=Umask::Local->new(0333);File::Find::find({wanted=>$wanted,no_chdir=>1 },'lib');return if$has_errors;install("succeeds for " .$BUILD->name);return 1}sub _builder_Makefile_PL ( $self, $name ) {my$make=App::cnext::Helpers::make_binary();my@cmds;my$use_dot=-d 'inc';my@test_cmd=($^X,$use_dot ? (qw{-I .}): (),"Makefile.PL");push@cmds,App::cnext::Installer::Command->new(log_level=>'configure',txt=>"perl " .join(' ',@test_cmd[1 .. $#test_cmd ]),cmd=>[@test_cmd],timeout=>$self->cli->configure_timeout,);push@cmds,App::cnext::Installer::Command->new(log_level=>'build',txt=>"make",cmd=>$make,timeout=>$self->cli->build_timeout,);if ($self->cli->run_tests){push@cmds,App::cnext::Installer::Command->new(log_level=>'test',txt=>"make test",cmd=>[$make,"test" ],timeout=>$self->cli->test_timeout,)}if ($self->run_install){push@cmds,App::cnext::Installer::Command->new(log_level=>'install',txt=>"make install",cmd=>[$make,"install" ],timeout=>$self->cli->install_timeout,)}for my$cmd (@cmds){return unless$cmd->run()}return 1}sub _builder_Build ( $self, $name ) {my@cmds;push@cmds,App::cnext::Installer::Command->new(log_level=>'configure',txt=>"perl Build.PL",cmd=>[$^X,"Build.PL" ],timeout=>$self->cli->configure_timeout,);push@cmds,App::cnext::Installer::Command->new(log_level=>'build',cmd=>"./Build",timeout=>$self->cli->configure_timeout,);if ($self->cli->run_tests){push@cmds,App::cnext::Installer::Command->new(log_level=>'test',cmd=>["./Build","test" ],timeout=>$self->cli->test_timeout,)}if ($self->run_install){push@cmds,App::cnext::Installer::Command->new(log_level=>'install',cmd=>["./Build","install" ],timeout=>$self->cli->install_timeout,)}for my$cmd (@cmds){return unless$cmd->run()}return 1}sub resolve_dependencies ( $self, $name ) {my$BUILD=$self->BUILD->{$name}or die;my@order=qw{requires_build requires_runtime};for my$type (@order){my$requires_list=$BUILD->{$type}// {};next unless scalar keys %$requires_list;resolve("$type for $name");for my$module (sort keys %$requires_list){my$version=$requires_list->{$module};resolve("\t$name $type $module v$version");return unless$self->install_single_module($module,$version)}}return 1}sub setup_tarball ( $self, $repository_info ) {my$name=$repository_info->{repository};my$tarball=$self->download_repository($repository_info);return unless defined$tarball;my$relative_path=$self->unpacker->unpack($tarball);my$full_path=$self->cli->build_dir .'/' .$relative_path;if (!defined$relative_path ||!-d $full_path){FAIL("fail to extract tarball $tarball");return}my$dir=pushd($full_path);return unless$self->load_BUILD_json;return 1}sub load_BUILD_json($self) {return unless my$BUILD=App::cnext::BUILD::create_from_file('BUILD.json');$self->BUILD->{$BUILD->name }=$BUILD;return$BUILD}sub download_repository ( $self, $repository_info ) {my$cli=$self->cli or die;my$url=$cli->repositories_idx->get_tarball_url($repository_info)or die;fetch($url);my$name=$repository_info->{repository};my$sha=$repository_info->{sha};my$tarball="${name}.tar.gz";my$path=$cli->build_dir ."/$tarball";unlink$path if -e $path;$cli->http->mirror($url,$path);if (!-e $path){DEBUG("Fail to download tarball from $url");return}my$signature=$repository_info->{signature};if ($self->cli->check_signature && defined$signature){if (!check_signature($path,$signature)){ERROR("Signature mismatch for $tarball expect: $signature");return}DEBUG("signature OK for $tarball = $signature")}return$path}sub tracking_module ( $self, $module ) {die unless defined$module;$module =~ s{\@.+$}{};return 1 if$self->{_tracked_modules}->{$module};$self->{_tracked_modules}->{$module}=1;return}sub tracking_repository ( $self, $repository ) {die unless defined$repository;$repository =~ s{\@.+$}{};return 1 if$self->{_tracked_repositories}->{$repository};$self->{_tracked_repositories}->{$repository}=1;return}1;
APP_CNEXT_INSTALLER

    $fatpacked{"App/cnext/Installer/Command.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INSTALLER_COMMAND';
  package App::cnext::Installer::Command;use App::cnext::std;use App::cnext::Logger;use App::cnext::Timeout ();use Simple::Accessor qw{txt cmd timeout env log_level};use App::cnext::IPC ();sub _build_log_level {'install'}sub _build_cmd {FATAL("cmd not defined for Command")}sub _build_timeout {0}sub _build_env {{}}sub _build_txt($self) {return$self->cmd unless ref$self->cmd;return join(' ',@{$self->cmd})}sub run($self) {my$log_level=$self->log_level;my$log_type=App::cnext::Logger->can($log_level)or FATAL("Unknown helper to log $log_level");$log_type->("running " .$self->txt);my ($status,$out,$err);my$todo=sub {($status,$out,$err)=App::cnext::IPC::run3($self->cmd,$self->log_level)};local%ENV=(%ENV,%{$self->env});if ($self->timeout){App::cnext::Timeout->new(message=>q[Reach timeout while running ] .$self->txt,timeout=>$self->timeout,)->run($todo)}else {$todo->()}if ($status!=0){ERROR("Fail to run " .$self->txt);return}return 1}1;
APP_CNEXT_INSTALLER_COMMAND

    $fatpacked{"App/cnext/Installer/Share.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INSTALLER_SHARE';
  package App::cnext::Installer::Share;use App::cnext::std;use App::cnext::Logger;use App::cnext::Helpers qw{is_valid_distribution_name};use File::Spec;use Umask::Local ();use Simple::Accessor qw{installdirs BUILD dist_dir};sub _build_dist_dir( $self ) {my$dist=$self->BUILD->name;FATAL("Invalid distribution name: '$dist'")unless is_valid_distribution_name($dist);return File::Spec->catdir('auto','share','dist',$dist)}sub module_dir ( $self, $module ) {$module =~ s/::/-/g;FATAL("Invalid module name: '$module'")if$module =~ m{\s};return File::Spec->catdir('auto','share','module',$module)}sub install_share_module($self) {return 1 unless -d q[share-module];my$has_errors=0;my$wanted=sub {return unless -f $File::Find::name;my$destination=$File::Find::name;$destination =~ s{^share-module/}{};my ($shared_module,$path)=split('/',$destination,2);if (!defined$path){ERROR("Invalid share-module path: $destination");++$has_errors;return}eval {$self->installdirs->install_to_lib($File::Find::name,File::Spec->catfile($self->module_dir($shared_module),$path));1}or ++$has_errors;return};File::Find::find({wanted=>$wanted,no_chdir=>1 },'share-module');return if$has_errors;return 1}sub install_share($self) {return 1 unless -d q[share];my$has_errors=0;my$wanted=sub {return unless -f $File::Find::name;my$destination=$File::Find::name;$destination =~ s{^share/}{};eval {$self->installdirs->install_to_lib($File::Find::name,File::Spec->catfile($self->dist_dir,$destination));1}or ++$has_errors;return};File::Find::find({wanted=>$wanted,no_chdir=>1 },'share');return if$has_errors;return 1}sub install($self) {my$umask=Umask::Local->new(0333);return$self->install_share && $self->install_share_module}1;
APP_CNEXT_INSTALLER_SHARE

    $fatpacked{"App/cnext/Installer/Unpacker.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_INSTALLER_UNPACKER';
  package App::cnext::Installer::Unpacker;use App::cnext::std;use App::cnext::IPC ();use File::Basename ();use File::Temp ();use File::Which ();use File::pushd;sub new ( $class, %argv ) {my$self=bless \%argv,$class;$self->_init_untar;return$self}sub unpack ( $self, $file ) {my$method=$self->{method}{untar};my$dir;$dir=pushd($self->{tmproot})if$self->{tmproot};return$self->can($method)->($self,$file)}sub _init_untar($self) {my$tar=$self->{tar}=File::Which::which('gtar')|| File::Which::which("tar");if ($tar){my ($exit,$out,$err)=App::cnext::IPC::run3 [$tar,'--version' ];$self->{tar_kind}=$out =~ /bsdtar/ ? "bsd" : "gnu";$self->{tar_bad}=1 if$out =~ /GNU.*1\.13/i || $^O eq 'MSWin32' || $^O eq 'solaris' || $^O eq 'hpux'}if ($tar and!$self->{tar_bad}){$self->{method}{untar}=*_untar;return if!$self->{_init_all}}my$gzip=$self->{gzip}=File::Which::which("gzip");my$bzip2=$self->{bzip2}=File::Which::which("bzip2");if ($tar && $gzip && $bzip2){$self->{method}{untar}=*_untar_bad;return if!$self->{_init_all}}if (eval {require Archive::Tar}){$self->{"Archive::Tar"}=Archive::Tar->VERSION;$self->{method}{untar}=*_untar_module;return if!$self->{_init_all}}return if$self->{_init_all};$self->{method}{untar}=sub {die "There is no backend for untar"}}sub _untar ( $self, $file ) {my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? 'j' : 'z';($exit,$out,$err)=App::cnext::IPC::run3 [$self->{tar},"${ar}tf",$file ];last if$exit!=0;my$root=$self->_find_tarroot(split /\r?\n/,$out);($exit,$out,$err)=App::cnext::IPC::run3 [$self->{tar},"${ar}xf",$file,"-o" ];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_bad ( $self, $file ) {my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? $self->{bzip2}: $self->{gzip};my$temp=File::Temp->new(SUFFIX=>'.tar',EXLOCK=>0);($exit,$out,$err)=App::cnext::IPC::run3 [$ar,"-dc",$file ],$temp->filename;last if$exit!=0;my@opt=$^O eq 'MSWin32' && $self->{tar_kind}ne "bsd" ? ('--force-local'): ();($exit,$out,$err)=App::cnext::IPC::run3 [$self->{tar},@opt,"-tf",$temp->filename ];last if$exit!=0 ||!$out;my$root=$self->_find_tarroot(split /\r?\n/,$out);($exit,$out,$err)=App::cnext::IPC::run3 [$self->{tar},@opt,"-xf",$temp->filename,"-o" ];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_module ( $self, $file ) {my$wantarray=wantarray;no warnings 'once';local$Archive::Tar::WARN=0;my$t=Archive::Tar->new;{my$ok=$t->read($file);last if!$ok;my$root=$self->_find_tarroot($t->list_files);my@file=$t->extract;return$root if@file and -d $root}return if!$wantarray;return (undef,$t->error)}sub _find_tarroot ( $self, $root, @others ) {FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length$root){$root=shift@others;redo FILE if$root}}return$root}1;
APP_CNEXT_INSTALLER_UNPACKER

    $fatpacked{"App/cnext/Logger.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_LOGGER';
  package App::cnext::Logger;use App::cnext::std;use List::Util 'max';use Exporter 'import';$|=1;our@EXPORT=qw{OK DONE FAIL ERROR WARN INFO DEBUG FATAL};our@EXPORT_OK=(@EXPORT,qw(fetch resolve install configure build test RUN STDERROR));our$COLOR;our$VERBOSE;our$DEBUG;our$SHOW_PROGRESS;BEGIN {$COLOR=1 if -t STDIN}use constant COLOR_RED=>31;use constant COLOR_GREEN=>32;use constant COLOR_YELLOW=>33;use constant COLOR_BLUE=>34;use constant COLOR_PURPLE=>35;use constant COLOR_CYAN=>36;use constant COLOR_WHITE=>7;my%color=(resolve=>COLOR_YELLOW,fetch=>COLOR_BLUE,configure=>COLOR_PURPLE,build=>COLOR_PURPLE,test=>COLOR_PURPLE,install=>COLOR_CYAN,FAIL=>COLOR_RED,ERROR=>COLOR_RED,STDERROR=>COLOR_RED,FATAL=>COLOR_RED,DONE=>COLOR_GREEN,OK=>COLOR_GREEN,WARN=>COLOR_YELLOW,INFO=>COLOR_GREEN,DEBUG=>COLOR_WHITE,RUN=>COLOR_WHITE,);sub new ( $class, @args ) {return bless {@args},$class}sub setup_for_script {$VERBOSE=1;$SHOW_PROGRESS=0;return}sub log ( $self_or_class, %options ) {my$type=$options{type}|| "";my$message=$options{message};chomp$message;my$optional=$options{optional}? " ($options{optional})" : "";my$result=$options{result};my$is_color=ref$self_or_class ? $self_or_class->{color}: $COLOR;my$verbose=ref$self_or_class ? $self_or_class->{verbose}: $VERBOSE;my$show_progress=ref$self_or_class ? $self_or_class->{show_progress}: $SHOW_PROGRESS;if (!$result && $DEBUG){my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);$year += 1900;$mon++;$result=sprintf('[%04d-%02d-%02d %02d:%02d:%02d]',$year,$mon,$mday,$hour,$min,$sec,)}$result //= '';if ($is_color){$type="\e[$color{$type}m$type\e[m" if$type && $color{$type};$result="\e[$color{$result}m$result\e[m" if$result && $color{$result};$optional="\e[1;37m$optional\e[m" if$optional}my$eol=$show_progress &&!$options{no_progress}? "" : "\n";my$r=$show_progress ? "\r\033[K" : "";if ($verbose){$type=$is_color && $type ? sprintf("%-17s",$type): sprintf("%-9s",$type || "");print STDERR$r .sprintf "%s %s %s%s$eol",$result,$type,$message,$optional}else {print STDERR$r .join(" ",map {defined $_ ? $_ : ()}$result,$type,$message .$optional).$eol}return}sub OK ( $msg, @args ) {return __PACKAGE__->log(type=>'OK',message=>$msg,no_progress=>1,@args)}sub DONE ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'DONE',message=>$msg,no_progress=>1,@args)}sub DEBUG ( $msg, @args ) {return unless$DEBUG;return __PACKAGE__->log(type=>'DEBUG',message=>$msg,@args)}sub RUN ( $msg, @args ) {return unless$DEBUG;return __PACKAGE__->log(type=>'RUN',message=>$msg,@args)}sub FAIL ( $msg, @args ) {return __PACKAGE__->log(type=>'FAIL',message=>$msg,no_progress=>1,@args)}sub ERROR ( $msg, @args ) {return __PACKAGE__->log(type=>'ERROR',message=>$msg,no_progress=>1,@args)}sub STDERROR ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'STDERROR',message=>$msg,no_progress=>1,@args)}sub FATAL ( $msg, @args ) {__PACKAGE__->log(type=>'FATAL',message=>$msg,no_progress=>1,@args);die$msg}sub WARN ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'WARN',message=>$msg,no_progress=>1,@args)}sub INFO ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'INFO',message=>$msg,@args)}sub fetch ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'fetch',message=>$msg,@args)}sub resolve ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'resolve',message=>$msg,@args)}sub configure ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'configure',message=>$msg,@args)}sub install ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'install',message=>$msg,@args)}sub build ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'build',message=>$msg,@args)}sub test ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'test',message=>$msg,@args)}1;
APP_CNEXT_LOGGER

    $fatpacked{"App/cnext/Module.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_MODULE';
  package App::cnext::Module;use App::cnext::std;use App::cnext::Logger;use App::cnext::IPC;use Exporter 'import';our@EXPORT=qw(has_module_version);our@EXPORT_OK=(@EXPORT,qw{get_module_version module_updated});my%CACHE;my%GOT;sub has_module_version ( $module, $version, $local_lib = undef ) {my$IN=_in($local_lib);$version //= 0;if (defined$CACHE{$module}&& defined$CACHE{$module}->{$IN}&& defined$CACHE{$module}->{$IN}->{$version}){return$CACHE{$module}->{$IN}->{$version}}$CACHE{$module}//= {};$CACHE{$module}->{$IN}//= {};my$has_module=0;my$got_version=get_module_version($module,$local_lib);$version =~ s{^\s*>=\s*}{};if (lc$module eq 'perl' && $version =~ m{^v?(\d+)\.(\d+)\.(\d+)$}ia){$version=sprintf("%d.%03d%03d",$1,$2,$3)}if (defined$got_version){if ($got_version eq $version){$has_module=1}else {my$version_check=eval qq{ $version > $got_version ? 0 : 1 };if (!defined$version_check){WARN("module $module version is not numeric: $got_version")}elsif ($version_check){$has_module=1}}}DEBUG("has_module $module >= $version ? $has_module [got " .($got_version // '').']');$CACHE{$module}->{$IN}->{$version}=$has_module;return$has_module}sub get_module_version ( $module, $local_lib = undef ) {my$IN=_in($local_lib);return$GOT{$module}->{$IN}if defined$GOT{$module}&& defined$GOT{$module}->{$IN};return "$]" if lc$module eq 'perl';my$version;if (!defined$local_lib){my$oneliner=qq|eval { require $module; 1 } or die; print eval { \$${module}::VERSION } // 0|;my ($status,$out,$err)=App::cnext::IPC::run3([$^X,'-e',$oneliner ]);if ($status==0){$version=$out;chomp$version if$version}}else {local$ENV{PERL5LIB};my$pp=$module;$pp =~ s{::}{/}g;$pp .= '.pm';my$oneliner=<<"EOS";my ($status,$out,$err)=App::cnext::IPC::run3([$^X,"-mlocal::lib=--no-create,$local_lib",'-e',$oneliner ]);if ($status==0){$version=$out;chomp$version if$version}}$GOT{$module}//= {};$GOT{$module}->{$IN}=$version;DEBUG("get_module_version $module = " .($version // ''));return$version}sub module_updated ( $module, $version, $local_lib = undef ) {die("Missing module name")unless defined$module;my$IN=_in($local_lib);delete$CACHE{$module};$GOT{$module}//= {};$GOT{$module}->{$IN}=$version;return}sub _in ( $local_lib = undef ) {return$local_lib // 'default'}sub clear_module( $module ) {delete$CACHE{$module};delete$GOT{$module};return}sub clear_cache {%CACHE=();%GOT=();return}1;
  eval { require $module; 1 } or die; 
  die unless \$INC{"$pp"} =~ m{^\Q$local_lib\E}; 
  print eval { \$${module}::VERSION } // 0;
  EOS
APP_CNEXT_MODULE

    $fatpacked{"App/cnext/Roles/JSON.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_ROLES_JSON';
  package App::cnext::Roles::JSON;use App::cnext::std;use JSON::PP ();use Simple::Accessor qw{json};sub _build_json($self) {return JSON::PP->new->utf8->relaxed->allow_nonref}1;
APP_CNEXT_ROLES_JSON

    $fatpacked{"App/cnext/Search/Result.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_SEARCH_RESULT';
  package App::cnext::Search::Result;use App::cnext::std;use App::cnext::Logger;use Simple::Accessor qw{_modules _repositories};sub _build__modules {{}}sub _build__repositories {{}}sub add_module ( $self, $name ) {$self->_modules->{$name}=1;return}sub add_repository ( $self, $name ) {$self->_repositories->{$name}=1;return}sub list_modules($self) {return [sort keys %{$self->_modules}]}sub list_repositories($self) {return [sort keys %{$self->_repositories}]}1;
APP_CNEXT_SEARCH_RESULT

    $fatpacked{"App/cnext/Signature.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_SIGNATURE';
  package App::cnext::Signature;use App::cnext::std;use App::cnext::Logger;use Digest::Perl::MD5;use Exporter 'import';our@EXPORT=qw{check_signature};our@EXPORT_OK=@EXPORT;sub check_signature ( $file, $expect ) {return unless -e $file && defined$expect;open(my$fh,'<:utf8',$file)or die "Cannot open file $file: $!";my$ctx=_get_ctx();$ctx->addfile($fh);return$ctx->hexdigest eq $expect}sub _get_ctx {state$warn_once;if (eval q{require Digest::MD5; 1 }){return Digest::MD5->new}if (!$warn_once){$warn_once=1;WARN("Consider installing Digest::MD5, using Digest::Perl::MD5")}return Digest::Perl::MD5->new}1;
APP_CNEXT_SIGNATURE

    $fatpacked{"App/cnext/Starter.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_STARTER';
  package App::cnext::Starter;use App::cnext::std;use App::cnext::Logger;use App::cnext::Helpers qw{write_file};use Simple::Accessor qw{distribution module primary_dir primary_file BUILD root_directory};use App::cnext::BUILD ();use File::Copy ();use File::Path qw(make_path);use File::Find ();use File::Basename ();use File::pushd;sub build ( $self, %opts ) {die "Missing module_or_distribution" unless my$module_or_distribution=delete$opts{module_or_distribution};die "Too many args" if scalar keys%opts;delete$self->{module_or_distribution};my$distribution;($distribution=$module_or_distribution)=~ s{::}{-}g;$distribution =~ s{-+}{-}g;$self->{distribution}=$distribution;return$self}sub _build_module($self) {my$module=$self->distribution;$module =~ s{-}{::}g;return$module}sub _build_root_directory($self) {my$distribution=$self->distribution;if ($distribution !~ m{^[a-zA-Z0-9-]+$}){ERROR("Invalid distribution name: $distribution");return}return$distribution}sub _build_primary_dir($self) {my$distribution=$self->distribution;if ($distribution =~ m{^(.+)-[^-]+$}){my$inlib=$1;$inlib =~ s{-}{/}g;FATAL("directory should not start by /")if$inlib =~ m{^/};return "lib/$inlib"}return "lib"}sub _build_primary_file($self) {my$distribution=$self->distribution;my@subs=split('-',$distribution);return$self->primary_dir .'/' .$subs[-1].'.pm'}sub create_root_directory($self) {return unless my$dir=$self->root_directory;return!!make_path($dir,{verbose=>0,mode=>0711 })}sub create_directories($self) {my@dirs=qw{t};push@dirs,$self->primary_dir;for my$d (@dirs){next if make_path($d,{verbose=>0,mode=>0711 });my$distribution=$self->distribution;ERROR("Fail to create sub directory '$d' for $distribution");return}return 1}sub add_primary_pm($self ) {my$file=$self->primary_file;my$module=$self->module;my$content=<<'EOS';$content =~ s{~module~}{$module}g;return eval {write_file($file,$content);1}}sub add_test($self) {my$module=$self->module;my$file=q[t/00-load.t];my$content=<<'EOS';$content =~ s{~module~}{$module}g;return eval {write_file($file,$content);1}}sub add_BUILD($self) {my$build=App::cnext::BUILD->new(abstract=>"Abstract for " .$self->distribution,name=>$self->distribution,primary=>$self->module,);push @{$build->maintainers},'Your Name <your@email.tld>';$build->provides->{$self->module }={file=>$self->primary_file,version=>$build->version,};return$build->save_to_file}sub git_init($self) {}sub create($self) {INFO("creating repository " .$self->distribution);return unless$self->create_root_directory();DEBUG("root = " .$self->root_directory);my$in_dir=pushd($self->root_directory);DEBUG("create sub directories");return unless$self->create_directories();DEBUG("add main .pm file");return unless$self->add_primary_pm();DEBUG("add unit test");return unless$self->add_test();DEBUG("add BUILD.json");return unless$self->add_BUILD();DEBUG("init git");$self->git_init();return 1}1;
  #!perl
  
  package ~module~;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.001';
  
  1;
  EOS
  #!perl
  
  use Test::More;
  
  use_ok "~module~";
  
  ok defined $~module~::VERSION, "VERSION set";
  
  done_testing;
  EOS
APP_CNEXT_STARTER

    $fatpacked{"App/cnext/Timeout.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_TIMEOUT';
  package App::cnext::Timeout;use App::cnext::std;use App::cnext::Logger;use Simple::Accessor qw{timeout message prevsig};sub run ( $self, $code ) {local$SIG{'ALRM'}=sub {FATAL$self->message;die};alarm($self->timeout);my@out=$code->();alarm(0);return@out}1;
APP_CNEXT_TIMEOUT

    $fatpacked{"App/cnext/cli.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CLI';
  package App::cnext::cli;use App::cnext::std;use App::cnext ();use App::cnext::Logger;use App::cnext::Http;use App::cnext::cmd::cpanfile ();use App::cnext::cmd::fromtarball ();use App::cnext::cmd::getrepo ();use App::cnext::cmd::help ();use App::cnext::cmd::install ();use App::cnext::cmd::look ();use App::cnext::cmd::selfinstall ();use App::cnext::cmd::selfupdate ();use App::cnext::cmd::search ();use App::cnext::cmd::start ();use App::cnext::cmd::test ();use App::cnext::cmd::version ();use App::cnext::Index::Repositories;use App::cnext::Index::Modules;use Cwd ();use Simple::Accessor qw{name http cwd homedir build_dir cache_dir local_lib snapshot retry configure_timeout build_timeout test_timeout install_timeout check_signature refresh run_tests installdirs features reinstall debug verbose repositories_idx modules_idx};use File::Path qw(mkpath rmtree);use Getopt::Long qw(:config no_auto_abbrev no_ignore_case bundling);use Pod::Text ();sub build ( $self, %options ) {for my$k (sort keys%options){$self->{$k}=$options{$k}}$self->cwd;my$defaults={check_signature=>1,with_requires=>1,with_recommends=>0,with_suggests=>0,with_configure=>0,with_build=>1,with_test=>1,with_runtime=>1,with_develop=>0,};for my$k (sort %$defaults){$self->{$k}//= $defaults->{$k}}$self->{features}=[];return$self}sub _build_cwd {return Cwd::cwd()}sub _build_homedir {$ENV{HOME}or die q[HOME environmenet variable not set]}sub _build_cache_dir($self) {my$path=$self->homedir .'/.cnext';return$path if -d $path;mkpath($path)or FATAL("Fail to create ~/.cnext cache directory directory at: $path");return$path}sub _build_build_dir($self) {my$path=$self->cache_dir .'/build';return$path if -d $path;mkpath($path)or die "fail to create build directory at: $path";return$path}sub DESTROY($self) {if (ref$self && $self->{builddir}&& $self->{cleanup}){my$dir=$self->{builddir};if (-d $dir &&!-l $dir){DEBUG("rmtree .build directory: $dir");File::Path::rmtree($dir)}}}sub _build_retry {1}sub _build_configure_timeout {60}sub _build_install_timeout {60}sub _build_build_timeout {3_600}sub _build_test_timeout {1_800}sub _build_http {App::cnext::Http->create}sub _build_repositories_idx($self) {App::cnext::Index::Repositories->new(cli=>$self)}sub _build_modules_idx($self) {App::cnext::Index::Modules->new(cli=>$self)}sub parse_options ( $self, @opts ) {local@ARGV=@opts;my (@feature);my$with_option=sub {my$n=shift;("with-$n",\$self->{"with_$n"},"without-$n",sub {$self->{"with_$n"}=0})};my@with_types=qw(requires recommends suggests);my@with_phases=qw(configure build test runtime develop);my$n_tests;GetOptions("color!"=>\($self->{color}),'cleanup!'=>\($self->{cleanup}),"cache|cache-dir=s"=>\($self->{cache_dir}),"check-signature!"=>\($self->{check_signature}),'test!'=>\($self->{run_tests}),'tests!'=>\($self->{run_tests}),'n'=>\$n_tests,"refresh"=>\($self->{refresh}),"reinstall"=>\($self->{reinstall}),"v|verbose"=>\($self->{verbose}),"d|debug"=>\($self->{debug}),"L|local-lib=s"=>\($self->{local_lib}),"installdir|installdirs=s"=>\($self->{installdirs}),"show-progress!"=>\($self->{show_progress}),"feature=s@"=>\@feature,"retry!"=>\($self->{retry}),"configure-timeout=i"=>\($self->{configure_timeout}),"build-timeout=i"=>\($self->{build_timeout}),"test-timeout=i"=>\($self->{test_timeout}),"install-timeout=i"=>\($self->{install_timeout}),"with-all"=>sub {map {$self->{"with_$_"}=1}@with_types,@with_phases},(map$with_option->($_),@with_types),(map$with_option->($_),@with_phases),)or exit 1;$self->{color}=1 if!defined$self->{color}&& -t STDOUT;if (!defined$self->{show_progress}&& -t STDOUT){if (scalar@ARGV > 1){$self->{show_progress}=1}else {$self->{show_progress}=0}}$self->{show_progress}=0 if$self->debug;$self->{show_progress}=0 unless -t STDIN;$self->{features}=\@feature if@feature;$self->{run_tests}=0 if$n_tests;$self->run_tests(1)unless defined$self->{run_tests};if (!$self->run_tests){$self->{'with_test'}=0}if (defined$self->{local_lib}){$self->{local_lib}=~ s{^=}{};$self->{local_lib}=Cwd::abs_path($self->local_lib)}if (defined$self->{local_lib}and defined$self->{installdirs}){FATAL("local_lib and installdir options are mutually exclusive.")}if (defined$self->{cache_dir}){$self->{cache_dir}=Cwd::abs_path($self->cache_dir);mkpath($self->cache_dir)unless -d $self->cache_dir;FATAL("Cannot find cache directory at " .$self->{cache_dir})unless -d $self->cache_dir}$self->{verbose}=1 if$self->{debug};$self->{cleanup}//= 1;$App::cnext::Logger::COLOR=1 if$self->{color};$App::cnext::Logger::VERBOSE=1 if$self->{verbose};$App::cnext::Logger::DEBUG=1 if$self->{debug};$App::cnext::Logger::SHOW_PROGRESS=1 if$self->{show_progress};if (@ARGV && $ARGV[0]eq "-"){$self->{argv}=$self->read_argv_from_stdin;$self->{cpanfile}=undef}else {$self->{argv}=\@ARGV}return$self}sub read_argv_from_stdin {my$self=shift;my@argv;while (my$line=<STDIN>){next if$line !~ /\S/;next if$line =~ /^\s*#/;$line =~ s/^\s*//;$line =~ s/\s*$//;push@argv,split /\s+/,$line}return \@argv}sub get_cmd_sub_for ( $self, $cmd ) {return unless defined$cmd;$cmd =~ s{^-+}{};$cmd =~ s{-}{}g;my$aliases={h=>'help',v=>'version',V=>'version',i=>'install',c=>'cpanfile',f=>'fromtarball','tests'=>'test',};$cmd=$aliases->{$cmd}if defined$aliases->{$cmd};return unless$cmd =~ m{^[A-Za-z0-9_]+$};return "App::cnext::cmd::$cmd"->can('run')}sub run ( $self, @argv ) {my$cmd='';my$run;if (scalar@argv){if ($run=$self->get_cmd_sub_for($argv[0])){$cmd=shift@argv}else {$run=$self->get_cmd_sub_for('install');$cmd='install'}}else {$run=$self->get_cmd_sub_for('help');$cmd='help'}die qq[Unknown subcommand '$cmd'] unless defined$run && ref$run eq 'CODE';$self->parse_options(@argv);$cmd =~ s{^-+}{} if$cmd;if ($cmd && $cmd !~ m{^(?:help|version)$}){INFO("Running action '$cmd'")}return$run->($self,@{$self->{argv}})}1;
APP_CNEXT_CLI

    $fatpacked{"App/cnext/cmd/cpanfile.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_CPANFILE';
  package App::cnext::cmd::cpanfile;use App::cnext::std;use App::cnext::Logger;use App::cnext::Installer;use App::cnext::Module qw(get_module_version);sub run ( $self, @files ) {my$installer=App::cnext::Installer->new(cli=>$self);return 1 unless _install_and_load_cpanfile($installer);push@files,'cpanfile' unless scalar@files;my@phases=grep$self->{"with_$_"},qw(configure build test runtime develop);my@types=grep$self->{"with_$_"},qw(requires recommends suggests);my@features=@{$self->features};for my$f (@files){$f='cpanfile' if$f eq '.';INFO("parsing cpanfile $f");my$cpanfile=Module::CPANfile->load($f);my$prereqs=$cpanfile->prereqs_with(@features);next unless$prereqs;my$reqs=$prereqs->merged_requirements(\@phases,\@types)->as_string_hash;next unless$reqs;if (my$need_perl_version=$reqs->{'perl'}){if ("$]" < $need_perl_version){ERROR("Needs Perl >= $need_perl_version, this is Perl $].");return 1}delete$reqs->{'perl'}}for my$module (sort keys %$reqs){my$version_range=$reqs->{$module};DEBUG("installing last version of $module");return 1 unless$installer->install_single_module($module,$version_range)}}DONE("install cpanfile succeeds");return 0}sub _install_and_load_cpanfile($installer) {return 1 if eval {require Module::CPANfile;1};WARN("Module::CPANfile is not available trying to install it");if (!$installer->install_single_module('Module::CPANfile')){ERROR("Fail to install Module::CPANfile");return}return eval {require Module::CPANfile;1}}1;
APP_CNEXT_CMD_CPANFILE

    $fatpacked{"App/cnext/cmd/fromtarball.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_FROMTARBALL';
  package App::cnext::cmd::fromtarball;use App::cnext::std;use App::cnext::Logger;use App::cnext::Installer;use App::cnext::BUILD;use File::Path ();use Cwd;sub run ( $cli, @args ) {do {ERROR("Need a single tarball");return 1}unless scalar@args==1;my$installer=App::cnext::Installer->new(cli=>$cli);my$tarball=$args[0];INFO("Installing module from tarball $tarball");return 1 unless my$path=setup_tarball($installer,$tarball);DEBUG("tarball is extracted at $path");return 1 unless$installer->install_from_file("$path/BUILD.json");File::Path::rmtree($path);DONE("install fromtarball succeeds");return 0}sub setup_tarball ( $installer, $tarball_or_url ) {my ($tarball,$has_downloaded)=download_if_needed($installer,$tarball_or_url);return unless defined$tarball && -f $tarball;DEBUG("Using tarball from $tarball");my$relative_path=$installer->unpacker->unpack($tarball);my$full_path=$installer->cli->build_dir .'/' .$relative_path;unlink($tarball)if$has_downloaded;if (!defined$relative_path ||!-d $full_path){FAIL("fail to extract tarball $tarball");return}return$full_path}sub download_if_needed ( $installer, $tarball_or_url ) {if ($tarball_or_url !~ m{^https?://}i){return Cwd::abs_path($tarball_or_url)if -e $tarball_or_url;ERROR("Do not know how to setup tarball: $tarball_or_url");return}my$basename="fromtarball-$$.tar.gz";my$path=$installer->cli->build_dir ."/$basename";App::cnext::Logger::fetch($tarball_or_url);$installer->cli->http->mirror($tarball_or_url,$path);return ($path,1)}1;
APP_CNEXT_CMD_FROMTARBALL

    $fatpacked{"App/cnext/cmd/getrepo.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_GETREPO';
  package App::cnext::cmd::getrepo;use App::cnext::std;use App::cnext::Logger;sub run ( $cli, @argv ) {die "Need one and only one argument" unless scalar@argv==1;require Module::CoreList;my$module=$argv[0];my$module_info=$cli->modules_idx->search($module);my$is_core=Module::CoreList->is_core($module);if ($module eq 'perl' || $is_core){my$first_release=Module::CoreList->first_release($module);say 'CORE',$first_release ? " v$first_release" : '';return}if (!ref$module_info &&!defined$module_info->{repository}){ERROR("Cannot find a repository for module '$module'");return 1}say$module_info->{repository};return}1;
APP_CNEXT_CMD_GETREPO

    $fatpacked{"App/cnext/cmd/help.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_HELP';
  package App::cnext::cmd::help;use App::cnext::std;use Pod::Text ();sub run ( $self, @argv ) {my$out;open my$fh,">",\$out;my$f=$INC{'App/cnext.pm'};$f=$0 unless -e $f;Pod::Text->new->parse_from_file($f,$fh);if (defined$out){$out =~ s/^[ ]{6}/    /mg;print STDERR$out}return 0}1;
APP_CNEXT_CMD_HELP

    $fatpacked{"App/cnext/cmd/install.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_INSTALL';
  package App::cnext::cmd::install;use App::cnext::std;use App::cnext::Logger;use App::cnext::Installer;sub run ( $self, @modules ) {return 1 unless scalar@modules;my$installer=App::cnext::Installer->new(cli=>$self);for my$module (@modules){if ($module eq '.'){INFO "Installing distribution from .";if (!$installer->install_from_file()){FAIL "Fail to install distribution from .";return 1}next}INFO("Looking for module: $module");if (!$installer->install_single_module_or_repository($module)){FAIL("Fail to install $module or its dependencies.");return 1}}DONE("install cmd succeeds");return 0}1;
APP_CNEXT_CMD_INSTALL

    $fatpacked{"App/cnext/cmd/look.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_LOOK';
  package App::cnext::cmd::look;use App::cnext::std;use App::cnext::Logger;use File::Which ();use File::Path qw(mkpath rmtree);use File::pushd;sub run ( $cli, @argv ) {die "Need one and only distribution or module name" unless scalar@argv==1 && defined$argv[0];die "Cannot detect STDIN" unless -t STDIN;my$module_or_distro=$argv[0];my$module_info=$cli->modules_idx->search($module_or_distro);my$repository_info;if (defined$module_info){$repository_info=$cli->repositories_idx->search($module_info->{repository})}else {$repository_info=$cli->repositories_idx->search($module_or_distro)}if (!$repository_info){ERROR("Cannot find distribution for '$module_or_distro'");return 1}my$repository_name=$repository_info->{repository};DEBUG("Found repository '$repository_name'");my$git=File::Which::which('git');if ($git && -x $git){my$url=$cli->repositories_idx->get_git_repository_url($repository_info);my$base_dir=$cli->cache_dir .'/git-repos';my$dir=$base_dir .'/' .$repository_name;mkpath($base_dir)unless -d $base_dir;rmtree($dir)if -d $dir;my ($exit,$out,$err)=App::cnext::IPC::run3([$git,'clone',$url,$dir ]);if ($exit!=0 ||!-d $dir){ERROR("Fail to clone git repository '$url'");return 1}{my$shell=$ENV{SHELL}|| File::Which::which('bash')|| File::Which::which('sh');if (!-x $shell){ERROR("Cannot find a valid shell, set SHELL env. variable");INFO("repository was cloned to $dir");INFO("     cd $dir");return 1}my$in_dir=pushd($dir);INFO("Opening a new shell session to '$dir'");system$shell}DEBUG("Removing temporary directory: '$dir'");rmtree($dir)if -d $dir}else {WARNING("Cannot find a git binary in your PATH");return 1}return}1;
APP_CNEXT_CMD_LOOK

    $fatpacked{"App/cnext/cmd/search.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_SEARCH';
  package App::cnext::cmd::search;use App::cnext::std;use App::cnext::Logger;use App::cnext::Installer;sub run ( $cli, @patterns ) {if (!scalar@patterns){ERROR("search needs one or more arguments");return 1}for my$pattern (@patterns){INFO("Search results for: $pattern");my$lookup=$pattern;$lookup =~ s{\Q.*\E}{*}g;$lookup =~ s{\Q*\E}{.*}g;$lookup =~ s{^\s+}{};$lookup =~ s{\s+$}{};my$result=$cli->modules_idx->regexp_search($lookup);my$repositories=$result->list_repositories;my$count_repos=scalar @$repositories;if ($count_repos){OK("Found $count_repos respositories matching '$pattern'");for my$repo (@$repositories){say$repo}}my$modules=$result->list_modules;my$count_modules=scalar @$modules;if ($count_modules){OK("Found $count_modules modules matching '$pattern'");for my$module (@$modules){say$module}}if (!$count_modules &&!$count_repos){ERROR("no results found for '$pattern'");return 1}}return 0}1;
APP_CNEXT_CMD_SEARCH

    $fatpacked{"App/cnext/cmd/selfinstall.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_SELFINSTALL';
  package App::cnext::cmd::selfinstall;use App::cnext::std;use App::cnext::Logger;use App::cnext::Installer;use App::cnext::Helpers qw{write_file is_fatpacked};use File::Basename ();use Cwd ();sub run ( $cli, @argv ) {if (!is_fatpacked()){FAIL("Can only install a FatPacked version of 'cnext'.");return 1}FATAL("No source code")unless length($main::SOURCE_CODE // '');App::cnext::Logger::setup_for_script();my$tmp_file=$cli->build_dir ."/cnext.tmp";write_file($tmp_file,$main::SOURCE_CODE);my$installer=App::cnext::Installer->new(cli=>$cli);my$dirs=$installer->installdirs;my$path=$dirs->install_to_bin($tmp_file,'cnext');OK "cnext is installed to $path";check_path_for($path);unlink$tmp_file;return}sub check_path_for($bin) {my$indir=File::Basename::dirname(Cwd::abs_path($bin));if (defined$ENV{PATH}){my@path=split(':',$ENV{PATH});for my$p (@path){next unless$p =~ m{^/};$p=Cwd::abs_path($p);return 1 if$p eq $indir}}WARN("$indir is not in your PATH");return}1;
APP_CNEXT_CMD_SELFINSTALL

    $fatpacked{"App/cnext/cmd/selfupdate.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_SELFUPDATE';
  package App::cnext::cmd::selfupdate;use App::cnext ();use App::cnext::std;use App::cnext::Logger;use App::cnext::Installer;use App::cnext::InstallDirs;use App::cnext::Helpers qw{write_file is_fatpacked update_shebang};use File::Basename ();use Cwd ();use File::Copy ();use constant URL=>q[http://get.cnext.us/];sub run ( $cli, @argv ) {if (!is_fatpacked()){FAIL("Can only update a FatPacked version of 'cnext'.");return 1}App::cnext::Logger::setup_for_script();my$force=grep {$_ eq 'force'}@argv;INFO("running 'selfupdate force'")if$force;my$installer=App::cnext::Installer->new(cli=>$cli);my$tmp_file=$installer->cli->build_dir ."/cnext.tmp";unlink$tmp_file if -e $tmp_file;$installer->cli->http->mirror(URL,$tmp_file);if (!-f $tmp_file || -z _){FAIL("Fail to download cnext from " .URL);return 1}my$current_version=$App::cnext::VERSION .'@' .$App::cnext::REVISION;my ($exit,$out,$err)=App::cnext::IPC::run3(["$^X",$tmp_file,q[--version] ]);my$new_version;if ($out && $out =~ m{^cnext\s+(\d+\.\d+\@\w+)\b}a){$new_version=$1}if ($exit || $err ||!defined$new_version ||!length$new_version){FAIL("Cannot get cnext version from " .URL);return 1}if (!$force && $current_version eq $new_version){OK("cnext is already up to date using version '$current_version'");INFO("you can force an update by running: cnext selfupdate force");return}DEBUG("current_version: $current_version ; target_version: $new_version");my$to_file=Cwd::abs_path($0);if (!-e $to_file){FAIL("Do not know how to update $0");return 1}update_shebang($tmp_file);DEBUG("cp $tmp_file $to_file");File::Copy::copy($tmp_file,$to_file)or do {FAIL("Cannot copy $tmp_file to $to_file");return 1};OK("cnext is updated to version '$new_version'");unlink$tmp_file;return}1;
APP_CNEXT_CMD_SELFUPDATE

    $fatpacked{"App/cnext/cmd/start.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_START';
  package App::cnext::cmd::start;use App::cnext::std;use App::cnext::Logger;use App::cnext::Starter;use Cwd;use File::pushd;sub run ( $cli, @modules ) {if (!scalar@modules){ERROR("Need one or more module / distribution name");return 1}my$root=getcwd;for my$module (@modules){my$in_dir=pushd($root);my$ok=eval {App::cnext::Starter->new(module_or_distribution=>$module)->create};if ($ok){OK("Directory for $module created.")}else {FAIL("Cannot create directory for $module.");DEBUG("Error: $@");return 1}}return 0}1;
APP_CNEXT_CMD_START

    $fatpacked{"App/cnext/cmd/test.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_TEST';
  package App::cnext::cmd::test;use App::cnext::std;use App::cnext::Logger;use App::cnext::Installer;sub run ( $cli, @modules ) {return 1 unless scalar@modules;my$installer=App::cnext::Installer->new(cli=>$cli,run_install=>0);if (!$cli->run_tests){ERROR("Cannot disable tests when using 'test' command.");return 1}for my$module (@modules){if ($module eq '.'){INFO "Testing distribution from .";if (!$installer->install_from_file()){FAIL "Fail to test distribution from .";return 1}next}INFO("Looking for module: $module");if (!$installer->install_single_module_or_repository($module)){FAIL("Fail to test $module or its dependencies.");return 1}}DONE("test succeeds");return 0}1;
APP_CNEXT_CMD_TEST

    $fatpacked{"App/cnext/cmd/version.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_CMD_VERSION';
  package App::cnext::cmd::version;use App::cnext::std;sub run ( $self, @argv ) {my$version=$App::cnext::VERSION;my$revision=$App::cnext::REVISION;say "cnext $version\@$revision ($0)";return}1;
APP_CNEXT_CMD_VERSION

    $fatpacked{"App/cnext/std.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CNEXT_STD';
  package App::cnext::std;use strict;use warnings;use utf8;sub import {warnings->import();strict->import();require feature;feature->import(':5.20');feature->import('signatures');utf8->import();warnings->unimport('experimental::signatures');return}1;
APP_CNEXT_STD

    $fatpacked{"Digest/Perl/MD5.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'DIGEST_PERL_MD5';
  package Digest::Perl::MD5;use strict;use integer;use Exporter;use vars qw($VERSION @ISA @EXPORTER @EXPORT_OK);@EXPORT_OK=qw(md5 md5_hex md5_base64);@ISA='Exporter';$VERSION='1.9';sub A() {0x67_45_23_01}sub B() {0xef_cd_ab_89}sub C() {0x98_ba_dc_fe}sub D() {0x10_32_54_76}sub MAX() {0xFFFFFFFF}sub padding {my$l=length(my$msg=shift().chr(128));$msg .= "\0" x (($l % 64 <= 56 ? 56 : 120)- $l % 64);$l=($l - 1)* 8;$msg .= pack 'VV',$l & MAX,($l >> 16 >> 16)}sub rotate_left($$) {($_[0]<< $_[1])| (($_[0]>> (32 - $_[1]))& ((1 << $_[1])- 1))}sub gen_code {my$MSK=((1 << 16)<< 16)? ' & ' .MAX : '';my%f=(FF=>"X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",GG=>"X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;",HH=>"X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;",II=>"X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",);my%s=(S11=>7,S12=>12,S13=>17,S14=>22,S21=>5,S22=>9,S23=>14,S24=>20,S31=>4,S32=>11,S33=>16,S34=>23,S41=>6,S42=>10,S43=>15,S44=>21);my$insert="\n";while (defined(my$data=<DATA>)){chomp$data;next unless$data =~ /^[FGHI]/;my ($func,@x)=split /,/,$data;my$c=$f{$func};$c =~ s/X(\d)/$x[$1]/g;$c =~ s/(S\d{2})/$s{$1}/;$c =~ s/^(.*)=rotate_left\((.*),(.*)\)\+(.*)$//;my$su=32 - $3;my$sh=(1 << $3)- 1;$c="$1=(((\$r=$2)<<$3)|((\$r>>$su)&$sh))+$4";$insert .= "\t$c\n"}close DATA;my$dump='
    sub round {
  	my ($a,$b,$c,$d) = @_[0 .. 3];
  	my $r;' .$insert .'
  	$_[0]+$a' .$MSK .', $_[1]+$b ' .$MSK .', $_[2]+$c' .$MSK .', $_[3]+$d' .$MSK .';
    }';eval$dump}gen_code();sub _encode_hex {unpack 'H*',$_[0]}sub _encode_base64 {my$res;while ($_[0]=~ /(.{1,45})/gs){$res .= substr pack('u',$1),1;chop$res}$res =~ tr|` -_|AA-Za-z0-9+/|;chop$res;chop$res;$res}sub new {my$proto=shift;my$class=ref$proto || $proto;my$self={};bless$self,$class;$self->reset();$self}sub reset {my$self=shift;delete$self->{_data};$self->{_state}=[A,B,C,D ];$self->{_length}=0;$self}sub add {my$self=shift;$self->{_data}.= join '',@_ if @_;my ($i,$c);for$i (0 .. (length$self->{_data})/ 64 - 1){my@X=unpack 'V16',substr$self->{_data},$i * 64,64;@{$self->{_state}}=round(@{$self->{_state}},@X);++$c}if ($c){substr($self->{_data},0,$c * 64)='';$self->{_length}+= $c * 64}$self}sub finalize {my$self=shift;$self->{_data}.= chr(128);my$l=$self->{_length}+ length$self->{_data};$self->{_data}.= "\0" x (($l % 64 <= 56 ? 56 : 120)- $l % 64);$l=($l - 1)* 8;$self->{_data}.= pack 'VV',$l & MAX,($l >> 16 >> 16);$self->add();$self}sub addfile {my ($self,$fh)=@_;if (!ref($fh)&& ref(\$fh)ne "GLOB"){require Symbol;$fh=Symbol::qualify($fh,scalar caller)}my$read=0;my$buffer='';$self->add($buffer)while$read=read$fh,$buffer,8192;die __PACKAGE__," read failed: $!" unless defined$read;$self}sub add_bits {my$self=shift;return$self->add(pack 'B*',shift)if @_==1;my ($b,$n)=@_;die __PACKAGE__," Invalid number of bits\n" if$n % 8;$self->add(substr$b,0,$n / 8)}sub digest {my$self=shift;$self->finalize();my$res=pack 'V4',@{$self->{_state}};$self->reset();$res}sub hexdigest {_encode_hex($_[0]->digest)}sub b64digest {_encode_base64($_[0]->digest)}sub clone {my$self=shift;my$clone={_state=>[@{$self->{_state}}],_length=>$self->{_length},_data=>$self->{_data}};bless$clone,ref$self || $self}sub md5 {my$message=padding(join '',@_);my ($a,$b,$c,$d)=(A,B,C,D);my$i;for$i (0 .. (length$message)/ 64 - 1){my@X=unpack 'V16',substr$message,$i * 64,64;($a,$b,$c,$d)=round($a,$b,$c,$d,@X)}pack 'V4',$a,$b,$c,$d}sub md5_hex {_encode_hex&md5}sub md5_base64 {_encode_base64&md5}1;__DATA__ FF,$a,$b,$c,$d,$_[4],7,0xd76aa478,/* 1 */
  FF,$d,$a,$b,$c,$_[5],12,0xe8c7b756,/* 2 */
  FF,$c,$d,$a,$b,$_[6],17,0x242070db,/* 3 */
  FF,$b,$c,$d,$a,$_[7],22,0xc1bdceee,/* 4 */
  FF,$a,$b,$c,$d,$_[8],7,0xf57c0faf,/* 5 */
  FF,$d,$a,$b,$c,$_[9],12,0x4787c62a,/* 6 */
  FF,$c,$d,$a,$b,$_[10],17,0xa8304613,/* 7 */
  FF,$b,$c,$d,$a,$_[11],22,0xfd469501,/* 8 */
  FF,$a,$b,$c,$d,$_[12],7,0x698098d8,/* 9 */
  FF,$d,$a,$b,$c,$_[13],12,0x8b44f7af,/* 10 */
  FF,$c,$d,$a,$b,$_[14],17,0xffff5bb1,/* 11 */
  FF,$b,$c,$d,$a,$_[15],22,0x895cd7be,/* 12 */
  FF,$a,$b,$c,$d,$_[16],7,0x6b901122,/* 13 */
  FF,$d,$a,$b,$c,$_[17],12,0xfd987193,/* 14 */
  FF,$c,$d,$a,$b,$_[18],17,0xa679438e,/* 15 */
  FF,$b,$c,$d,$a,$_[19],22,0x49b40821,/* 16 */ 
  GG,$a,$b,$c,$d,$_[5],5,0xf61e2562,/* 17 */
  GG,$d,$a,$b,$c,$_[10],9,0xc040b340,/* 18 */
  GG,$c,$d,$a,$b,$_[15],14,0x265e5a51,/* 19 */
  GG,$b,$c,$d,$a,$_[4],20,0xe9b6c7aa,/* 20 */
  GG,$a,$b,$c,$d,$_[9],5,0xd62f105d,/* 21 */
  GG,$d,$a,$b,$c,$_[14],9,0x2441453,/* 22 */
  GG,$c,$d,$a,$b,$_[19],14,0xd8a1e681,/* 23 */
  GG,$b,$c,$d,$a,$_[8],20,0xe7d3fbc8,/* 24 */
  GG,$a,$b,$c,$d,$_[13],5,0x21e1cde6,/* 25 */
  GG,$d,$a,$b,$c,$_[18],9,0xc33707d6,/* 26 */
  GG,$c,$d,$a,$b,$_[7],14,0xf4d50d87,/* 27 */
  GG,$b,$c,$d,$a,$_[12],20,0x455a14ed,/* 28 */
  GG,$a,$b,$c,$d,$_[17],5,0xa9e3e905,/* 29 */
  GG,$d,$a,$b,$c,$_[6],9,0xfcefa3f8,/* 30 */
  GG,$c,$d,$a,$b,$_[11],14,0x676f02d9,/* 31 */
  GG,$b,$c,$d,$a,$_[16],20,0x8d2a4c8a,/* 32 */
  HH,$a,$b,$c,$d,$_[9],4,0xfffa3942,/* 33 */
  HH,$d,$a,$b,$c,$_[12],11,0x8771f681,/* 34 */
  HH,$c,$d,$a,$b,$_[15],16,0x6d9d6122,/* 35 */
  HH,$b,$c,$d,$a,$_[18],23,0xfde5380c,/* 36 */
  HH,$a,$b,$c,$d,$_[5],4,0xa4beea44,/* 37 */
  HH,$d,$a,$b,$c,$_[8],11,0x4bdecfa9,/* 38 */
  HH,$c,$d,$a,$b,$_[11],16,0xf6bb4b60,/* 39 */
  HH,$b,$c,$d,$a,$_[14],23,0xbebfbc70,/* 40 */
  HH,$a,$b,$c,$d,$_[17],4,0x289b7ec6,/* 41 */
  HH,$d,$a,$b,$c,$_[4],11,0xeaa127fa,/* 42 */
  HH,$c,$d,$a,$b,$_[7],16,0xd4ef3085,/* 43 */
  HH,$b,$c,$d,$a,$_[10],23,0x4881d05,/* 44 */
  HH,$a,$b,$c,$d,$_[13],4,0xd9d4d039,/* 45 */
  HH,$d,$a,$b,$c,$_[16],11,0xe6db99e5,/* 46 */
  HH,$c,$d,$a,$b,$_[19],16,0x1fa27cf8,/* 47 */
  HH,$b,$c,$d,$a,$_[6],23,0xc4ac5665,/* 48 */
  II,$a,$b,$c,$d,$_[4],6,0xf4292244,/* 49 */
  II,$d,$a,$b,$c,$_[11],10,0x432aff97,/* 50 */
  II,$c,$d,$a,$b,$_[18],15,0xab9423a7,/* 51 */
  II,$b,$c,$d,$a,$_[9],21,0xfc93a039,/* 52 */
  II,$a,$b,$c,$d,$_[16],6,0x655b59c3,/* 53 */
  II,$d,$a,$b,$c,$_[7],10,0x8f0ccc92,/* 54 */
  II,$c,$d,$a,$b,$_[14],15,0xffeff47d,/* 55 */
  II,$b,$c,$d,$a,$_[5],21,0x85845dd1,/* 56 */
  II,$a,$b,$c,$d,$_[12],6,0x6fa87e4f,/* 57 */
  II,$d,$a,$b,$c,$_[19],10,0xfe2ce6e0,/* 58 */
  II,$c,$d,$a,$b,$_[10],15,0xa3014314,/* 59 */
  II,$b,$c,$d,$a,$_[17],21,0x4e0811a1,/* 60 */
  II,$a,$b,$c,$d,$_[8],6,0xf7537e82,/* 61 */
  II,$d,$a,$b,$c,$_[15],10,0xbd3af235,/* 62 */
  II,$c,$d,$a,$b,$_[6],15,0x2ad7d2bb,/* 63 */
  II,$b,$c,$d,$a,$_[13],21,0xeb86d391,/* 64 */
DIGEST_PERL_MD5

    $fatpacked{"File/Which.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'FILE_WHICH';
  package File::Which;use strict;use warnings;use Exporter ();use File::Spec ();our$VERSION='1.23';our@ISA='Exporter';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if ($^O eq 'MSWin32'){@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base .$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1 .. $#PATHEXT ])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

    $fatpacked{"File/pushd.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

    $fatpacked{"HTTP/Tinyish.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.15';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my ($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my ($self,$url)=@_;my ($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my ($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

    $fatpacked{"HTTP/Tinyish/Base.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my ($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if (/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my ($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my ($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

    $fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version' ],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my ($class,%attr)=@_;bless \%attr,$class}sub request {my ($self,$method,$url,$opts)=@_;$opts ||= {};my (undef,$temp)=File::Temp::tempfile(UNLINK=>1);my ($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my ($self,$url,$file,$opts)=@_;$opts ||= {};my (undef,$temp)=File::Temp::tempfile(UNLINK=>1);my ($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my ($self,$url,$opts)=@_;my@options=('--location','--silent','--max-time',($self->{timeout}|| 60),'--max-redirs',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my ($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

    $fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my ($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

    $fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my ($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my ($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field }=$hdrs->header($field)}\%headers}sub request {my ($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my ($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my ($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(delete$attr{max_redirect}|| 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my ($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

    $fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_ ],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my (undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my ($class,%attr)=@_;bless \%attr,$class}sub request {my ($self,$method,$url,$opts)=@_;$opts ||= {};my ($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my ($self,$url,$file,$opts)=@_;$opts ||= {};my ($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file ],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my ($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my ($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

    $fatpacked{"IPC/Run3.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

    $fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_},$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

    $fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_},$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

    $fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_},$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

    $fatpacked{"IPC/Run3/ProfPP.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

    $fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_},$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time) }=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

    $fatpacked{"Simple/Accessor.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'SIMPLE_ACCESSOR';
  package Simple::Accessor;$Simple::Accessor::VERSION='1.13';use strict;use warnings;my$INFO;sub import {my ($class,@attr)=@_;my$from=caller();$INFO={}unless defined$INFO;$INFO->{$from}={}unless defined$INFO->{$from};$INFO->{$from}->{'attributes'}=[@attr];_add_with($from);_add_new($from);_add_accessors(to=>$from,attributes=>\@attr);return}sub _add_with {my$class=shift;return unless$class;my$with=$class .'::with';{no strict 'refs';*$with=sub {my (@what)=@_;$INFO->{$class}->{'with'}=[]unless$INFO->{$class}->{'with'};push @{$INFO->{$class}->{'with'}},@what;for my$module (@what){eval qq[require $module; 1] or die $@;_add_accessors(to=>$class,attributes=>$INFO->{$module}->{attributes},from_role=>$module)}return}}}sub _add_new {my$class=shift;return unless$class;my$new=$class .'::new';{no strict 'refs';*$new=sub {my ($class,%opts)=@_;my$self=bless {},$class;map {eval {$self->$_($opts{$_})}}keys%opts;if ($self->can('_before_build')){$self->_before_build(%opts)}for my$init ('build','initialize'){if ($self->can($init)){return unless$self->$init(%opts)}}if ($self->can('_after_build')){$self->_after_build(%opts)}return$self}}}sub _add_accessors {my (%opts)=@_;return unless my$class=$opts{to};my@attributes=@{$opts{attributes}};return unless@attributes;my$from_role=$opts{from_role};for my$att (@attributes){my$accessor=$class ."::" .$att;die "$class: attribute '$att' is already defined." if$class->can($att);no strict 'refs';*$accessor=sub {my ($self,$v)=@_;if (defined$v){for (qw{before validate set after}){if ($_ eq 'set'){$self->{$att}=$v;next}my$sub='_' .$_ .'_' .$att;if ($self->can($sub)){return unless$self->$sub($v)}elsif ($from_role){if (my$code=$from_role->can($sub)){return unless$code->($self,$v)}}}}elsif (!defined$self->{$att}){for my$builder (qw{build initialize}){my$sub='_' .$builder .'_' .$att;if ($self->can($sub)){return$self->{$att}=$self->$sub()}elsif ($from_role){if (my$code=$from_role->can($sub)){return$self->{$att}=$code->($self)}}}}return$self->{$att}}}@attributes=()}1;
SIMPLE_ACCESSOR

    $fatpacked{"Umask/Local.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'UMASK_LOCAL';
  package Umask::Local;our$VERSION='1.0';use strict;use warnings;use base qw(Exporter);our@EXPORTS=qw(umask_localize);sub new {my$proto=shift;my$mask=shift;my$class=ref($proto)|| $proto;my$old_umask=umask($mask);return bless \$old_umask,$class}sub val {${$_[0]}}sub umask_localize {Umask::Local->new($_[0])}sub DESTROY {umask ${$_[0]}}1;
UMASK_LOCAL

    s/^  //mg for values %fatpacked;

    my $class = 'FatPacked::' . ( 0 + \%fatpacked );
    no strict 'refs';
    *{"${class}::files"} = sub { keys %{ $_[0] } };

    if ( $] < 5.008 ) {
        *{"${class}::INC"} = sub {
            if ( my $fat = $_[0]{ $_[1] } ) {
                my $pos  = 0;
                my $last = length $fat;
                return (
                    sub {
                        return 0 if $pos == $last;
                        my $next = ( 1 + index $fat, "\n", $pos ) || $last;
                        $_ .= substr $fat, $pos, $next - $pos;
                        $pos = $next;
                        return 1;
                    }
                );
            }
        };
    }

    else {
        *{"${class}::INC"} = sub {
            if ( my $fat = $_[0]{ $_[1] } ) {
                open my $fh, '<', \$fat
                  or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
                return $fh;
            }
            return;
        };
    }

    unshift @INC, bless \%fatpacked, $class;
}    # END OF FATPACK CODE

use strict;
use warnings;

use App::cnext::cli ();

unless (caller) {
    exit( App::cnext::cli->new( name => "App::cnext" )->run(@ARGV) // 0 );
}

1;

### DO NOT EDIT POD HERE, adjuts cnext.pm
## __CNEXT_POD_MARKER__

=encoding utf8

=head1 NAME

App::cnext -  CPAN client using next-cpan indexes

=head1 SYNOPSIS

    # Install one ore more distribution [using module or distribution names]
    cnext Cwd
    cnext Cwd File::Copy

    cnext install Cwd
    cnext install Cwd File::Copy

    cnext install --verbose Cwd  # more output
    cnext install --debug Cwd    # additional debug informations

    # install a specific version or trial version
    cnext install Devel-PPPort@3.57
    cnext install Devel-PPPort@3.57_02

    # preserve .cpbuild directory to preserve cache and debug
    cnext install --no-cleanup --verbose A1z::Html

    # install the distribution from current directory
    cnext install .

    # install distributions from a cpanfile
    cnext cpanfile .
    cnext cpanfile ~/my-custom.cpanfile

    # Getting a repository / distribution name for a module
    cnext get-repo Simple::Accessor

    # Clone a distribution to investigate / patch in a SHELL session
    cnext look Simple-Accessor

    # Only run unit tests without installing any distributions
    cnext test Simple-Accessor
    # Run test for the distribution in the current directory
    cnext test .

    cnext --version
    cnext --help

Run C<cnext -h> or C<perldoc cnext> for more options.

=head1 DESCRIPTION

This repository provides the `cnext` client to install Perl modules without using PAUSE.
This is using the `next-cpan` GitHub repositories indexed by `next-indexes`

L<https://ix.cnext.us|https://ix.cnext.us>

Rather than using distribution tarball from PAUSE itself, `play` is relying on GitHub infrastructure to download distributions.

The repo `next-indexes` host some index files which can be consumed to download and install most Perl modules.

`cnext` is the recommended CPAN client using these indexes and GitHub repositories.
You can read more about cnext client on the L<cnext website cnext.us|https://cnext.us>.

=head1 INSTALLATION

=head2 Installing to system perl

This is using cnext to install itself.

    curl -sL https://git.io/cnext | perl - self-install
    cnext --version

Or if you are not using root

    sudo curl -sL https://git.io/cnext | perl - self-install

You can also select where you want to install the script using installdirs

    curl -sL https://git.io/cnext | perl - self-install --installdirs=site  # this is the default
    curl -sL https://git.io/cnext | perl - self-install --installdirs=perl
    curl -sL https://git.io/cnext | perl - self-install --installdirs=vendor


=head2 Local installation

You can also download and install cnext to any custom location.

   curl -fsSL --compressed http://get.cnext.us > cnext
   chmod +x cnext
   ./cnext --version

=head1 How to use cnext

=head2 Install a Perl Module

   # install a single module
   cnext A1z::Html
   cnext install A1z::Html
   cnext install --verbose A1z::Html

   # install multiple modules
   cnext First::Module Second::Module ...

=head2 Install a Perl distribution

You could use either a module name or a distribution name.

   # install a single distribution
   cnext A1z-Html
   cnext install A1z-Html
   cnext install --verbose A1z-Html

   # install multiple modules
   cnext First-Distribution Second-Distribution

   # install a custom version
   cnext A1z-Html@0.04

   # install a trial version
   cnext Devel-PPPort@3.57_02

=head2 Mix Perl modules and distributions

   cnext Module::Name Distribution-Name ...

=head2 Install Perl Modules from a cpanfile

    # by default use ./cpanfile
    cnext cpanfile
    cnext cpanfile .
    cnext cpanfile ~/cpanfile.custom

    # use one or more cpanfiles
    cnext cpanfile ~/cpanfile.1 ~/cpanfile.2 ...

    # set some feature with cpanfile
    cnext cpanfile --feature one --feature two

    # set some types/phases
    cnext cpanfile --with-requires --with-build --with-runtime --with-test

    # shortcut to enable all
    cnext cpanfile --with-all

=head2 Install a development or TRIAL version

   # install a trial version
   cnext Devel-PPPort@3.57_02

=head2 Install a module from a custom repository

   cnext --from-tarball ./path-to/custom.tar.gz
   # where :owner, :repository and :sha are replaced with the accurate values
   cnext --from-tarball https://github.com/:owner/:repository/archive/:sha.tar.gz

   cnext --from-tarball -d https://github.com/next-cpan/A1z-Html/archive/p5.tar.gz

=head2 Install one distribution to a custom directory

By default modules are install to the current @INC, but you can specify a custom directory
where to install these modules using -L.

   cnext -L ~/vendor Simple-Accessor

=head2 Set destination

You can setup the installdir destination you are targetting.
Possible values are: perl, site, vendor (default: site)

                                   INSTALLDIRS set to
                             perl        site          vendor

                   PERLPREFIX      SITEPREFIX          VENDORPREFIX
    INST_ARCHLIB   INSTALLARCHLIB  INSTALLSITEARCH     INSTALLVENDORARCH
    INST_LIB       INSTALLPRIVLIB  INSTALLSITELIB      INSTALLVENDORLIB
    INST_BIN       INSTALLBIN      INSTALLSITEBIN      INSTALLVENDORBIN
    INST_SCRIPT    INSTALLSCRIPT   INSTALLSITESCRIPT   INSTALLVENDORSCRIPT
    INST_MAN1DIR   INSTALLMAN1DIR  INSTALLSITEMAN1DIR  INSTALLVENDORMAN1DIR
    INST_MAN3DIR   INSTALLMAN3DIR  INSTALLSITEMAN3DIR  INSTALLVENDORMAN3DIR

Sample usages:

    cnext install A1z-Html                     # install to site directories by default
    cnext install --installdir=site   A1z-Html  # site is the default
    cnext install --installdir=vendor A1z-Html
    cnext install --installdir=perl   A1z-Html

=head2 Checking a repository

This will clone and open a SHELL in a temporary directory,
removed once you exit the session.

  cnext look A1z::Html
  cnext look A1z-Html

=head2 Testing a distribution

You can test a distribution without installing it.

  cnext test Your-Distribution
  cnext test -v Your-Distribution # with some verbose output
  cnext test -d Your-Distribution # with some debug output

You can also test a distribution described by the BUILD.json in the current directory.

  cnext test .

=head1 USAGE

  cnext [ACTION] [OPTIONS] [ARGS]

=head2 ACTIONS

      install             default action to install distributions
      cpanfile            install dependencies from a cpanfile
      fromtarabll         install a distribution from a tarball
      selfupdate          selfupdate cnext binary
      selfinstall         selfinstall the binary
      help                display this documentation
      look                Clones & opens the distribution with your SHELL

=head2 OPTIONS

=head2 Generic options

       --no-cleanup         preserve the .cpbuild directory
   -v, --verbose            Turns on chatty output
   -d, --debug              enable --verbose and display some additional informations
       --show-progress --no-show-progress
                            show progress, default: on
       --refresh            force refresh the index files
       --color, --no-color  turn on/off color output, default: on
       --test               run test cases, default: on
   -n, --no-test
       --reinstall          reinstall the distribution(s)/module(s) even if you already have the latest version installed
                            do not apply to dependencies
       --cache-dir, --cache specify an alternate cache directory (default: ~/.cnext)
       --no-check-signature disable signature check (default: on)

       --configure-timeout  Timeout for configuring a distibution  (default: 60)
       --build-timeout      Timeout for building a distribution    (default: 3600)
       --test-timeout       Timeout for running tests              (default: 1800)
       --install-timeout    Timeout forinstalling files            (default: 60)
       use a value of '0' to disable a timeout
   -L, --local-lib DIR      Specify the install base directory to install all modules.
       --installdir TYPE    Set installation destination, possible values are perl, site, vendor (default:site)

=head2 cpanfile options

       --feature=identifier
         specify the feature to enable in cpanfile; you can use --feature multiple times
       --with-requires,   --without-requires   (default: with)
       --with-recommends, --without-recommends (default: without)
       --with-suggests,   --without-suggests   (default: without)
       --with-configure,  --without-configure  (default: without)
       --with-build,      --without-build      (default: with)
       --with-test,       --without-test       (default: with)
       --with-runtime,    --without-runtime    (default: with)
       --with-develop,    --without-develop    (default: without)
       --with-all         shortcut for
                          --with-requires --with-recommends --with-suggests \
                          --with-configure --with-build --with-test --with-runtime --with-develop
         specify types/phases of dependencies in cpanfile to be installed


