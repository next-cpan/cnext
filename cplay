#!/usr/bin/env perl

BEGIN {
    if ( "$]" < 5.019 ) {    # needs 5.20 for function signature
        die <<"EOS";
$0 is not supported on Perl $]
	cplay needs Perl 5.20 or higher
	please consider alternate solutions such as App::cpanminus or App::cpm
EOS
    }
}

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
    my %fatpacked;

    $fatpacked{"App/cplay.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY';
  package App::cplay;our$VERSION="0.0001";1;
APP_CPLAY

    $fatpacked{"App/cplay/Helpers.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_HELPERS';
  package App::cplay::Helpers;use App::cplay::std;use Exporter 'import';our@EXPORT_OK=qw(read_file zip);sub read_file($file) {local $/;open(my$fh,'<:utf8',$file)or die "Fail to open file: $!";return readline($fh)}sub zip : prototype(\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {my$max=-1;$max < $#$_ && ($max=$#$_)foreach @_;map {my$ix=$_;map $_->[$ix],@_}0 .. $max}1;
APP_CPLAY_HELPERS

    $fatpacked{"App/cplay/Http.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_HTTP';
  package App::cplay::Http;use App::cplay::std;use App::cplay ();use HTTP::Tinyish;sub create ( $class, %args ) {my@try=$args{prefer}? @{$args{prefer}}: qw(HTTPTiny LWP Curl Wget);my ($backend,$tool,$desc);for my$try (map "HTTP::Tinyish::$_",@try){my$meta=HTTP::Tinyish->configure_backend($try)or next;$try->supports("https")or next;($tool)=sort keys %$meta;($desc=$meta->{$tool})=~ s/^(.*?)\n.*/$1/s;$backend=$try,last}die "Couldn't find HTTP Clients that support https" unless$backend;my$http=$backend->new(agent=>"App::cplay/$App::cplay::VERSION",timeout=>60,verify_SSL=>1,%args,);my$keep_alive=exists$args{keep_alive}? $args{keep_alive}: 1;if ($keep_alive and $backend =~ /LWP$/){$http->{ua}->conn_cache({total_capacity=>1 })}return$http}1;
APP_CPLAY_HTTP

    $fatpacked{"App/cplay/Index.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INDEX';
  package App::cplay::Index;use App::cplay::std;use App::cplay::Logger;use constant BASE_URL=>q[https://pause-play.github.io/pause-index/];use constant MODULES_IX_BASENAME=>'module.idx';use constant REPOSITORIES_IX_BASENAME=>'repositories.idx';use constant EXPLICIT_VERSIONS_IX_BASENAME=>'explicit_versions.idx';my$_MODULES_IX_FILE;my$_REPOSITORIES_IX_FILE;my$_EXPLICIT_VERSIONS_IX_FILE;sub setup_once($cli) {no warnings 'redefine';*setup_once=sub {};ref$cli eq 'App::cplay::cli' or die "cli is not one App::cplay: $cli";my$homedir=$cli->homedir;$_MODULES_IX_FILE="$homedir/.cplay." .MODULES_IX_BASENAME;$_REPOSITORIES_IX_FILE="$homedir/.cplay." .REPOSITORIES_IX_BASENAME;$_EXPLICIT_VERSIONS_IX_FILE="$homedir/.cplay." .EXPLICIT_VERSIONS_IX_BASENAME;my@files=([$_MODULES_IX_FILE,BASE_URL .'/' .MODULES_IX_BASENAME,],[$_REPOSITORIES_IX_FILE,BASE_URL .'/' .REPOSITORIES_IX_BASENAME,],[$_EXPLICIT_VERSIONS_IX_FILE,BASE_URL .'/' .EXPLICIT_VERSIONS_IX_BASENAME,],);my$http=$cli->http;INFO("Check and refresh cplay index files.");for my$list (@files){my ($local,$remote)=@$list;$http->mirror($remote,$local)}return}sub get_modules_ix_file($cli) {setup_once($cli);return$_MODULES_IX_FILE}sub get_repositories_ix_file($cli) {setup_once($cli);return$_REPOSITORIES_IX_FILE}sub get_explicit_versions_ix_file($cli) {setup_once($cli);return$_EXPLICIT_VERSIONS_IX_FILE}1;
APP_CPLAY_INDEX

    $fatpacked{"App/cplay/Index/ExplicitVersions.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INDEX_EXPLICITVERSIONS';
  package App::cplay::Index::ExplicitVersions;use App::cplay::std;use App::cplay::Index;use Simple::Accessor qw{file cli};sub build ( $self, %opts ) {$self->{file}=App::cplay::Index::get_explicit_versions_ix_file($self->cli);return$self}1;
APP_CPLAY_INDEX_EXPLICITVERSIONS

    $fatpacked{"App/cplay/Index/Modules.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INDEX_MODULES';
  package App::cplay::Index::Modules;use App::cplay::std;use App::cplay::Index;use App::cplay::Helpers qw{read_file zip};use App::cplay::Logger;use JSON::PP ();use Simple::Accessor qw{file cli cache json columns};sub build ( $self, %opts ) {$self->{file}=App::cplay::Index::get_modules_ix_file($self->cli);return$self}sub _build_cache($self) {return$self->json->decode(read_file($self->file))}sub _build_json($self) {return JSON::PP->new->utf8->allow_nonref}sub _build_columns($self) {my$columns={};my$ix=0;for my$name ($self->cache->{columns}->@*){$columns->{$name}=$ix++}return$columns}sub search ( $self, $module ) {INFO("search $module");return unless my$cache=$self->cache;my$ix=$self->columns->{module};for my$raw ($cache->{data}->@*){if ($raw->[$ix]eq $module){return {zip($cache->{columns}->@*,$raw->@*)}}}return}sub quick_search ( $self, $module ) {}1;
APP_CPLAY_INDEX_MODULES

    $fatpacked{"App/cplay/Index/Repositories.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INDEX_REPOSITORIES';
  package App::cplay::Index::Repositories;use App::cplay::std;use App::cplay::Index;use App::cplay::Helpers qw{read_file zip};use App::cplay::Logger;use JSON::PP ();use Simple::Accessor qw{file cli cache json columns template_url};sub build ( $self, %opts ) {$self->{file}=App::cplay::Index::get_repositories_ix_file($self->cli);return$self}sub _build_cache($self) {return$self->json->decode(read_file($self->file))}sub _build_json($self) {return JSON::PP->new->utf8->allow_nonref}sub _build_template_url($self) {$self->cache->{template_url}or die}sub _build_columns($self) {my$columns={};my$ix=0;for my$name ($self->cache->{columns}->@*){$columns->{$name}=$ix++}return$columns}sub search ( $self, $repository, $version = undef ) {INFO("search repository $repository / " .($version // 'undef'));return unless my$cache=$self->cache;my$repository_ix=$self->columns->{repository};my$version_ix=$self->columns->{version};for my$raw ($cache->{data}->@*){next unless$raw->[$repository_ix]eq $repository;if (!defined$version || $version eq $raw->[$version_ix]){return {zip($cache->{columns}->@*,$raw->@*)}}return}return}sub get_tarball_url ( $self, $repository ) {die unless ref$repository;my$url=$self->template_url;$url =~ s{:([a-z0-9]+)}{$repository->{$1}}g;return$url}1;
APP_CPLAY_INDEX_REPOSITORIES

    $fatpacked{"App/cplay/Installer.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INSTALLER';
  package App::cplay::Installer;use App::cplay::std;use App::cplay;use App::cplay::Logger;use App::cplay::Module;use App::cplay::Installer::Unpacker ();use App::cplay::Helpers qw{read_file};use Test::More;use File::pushd;use IPC::Run3 ();App::cplay::Logger->import(qw{fetch configure install resolve});use Simple::Accessor qw{cli unpacker json BUILD};use constant EXTUTILS_MAKEMAKER_MIN_VERSION=>'6.64';sub build ( $self, %opts ) {$self->{_tracked_modules}={};$self->{_tracked_repositories}={};$self->{BUILD}={};return$self}sub _build_unpacker($self) {App::cplay::Installer::Unpacker->new(tmproot=>$self->cli->builddir)}sub _build_json($self) {return JSON::PP->new->utf8->allow_nonref}sub run3 ( $cmd, $outfile = undef ) {my$out;IPC::Run3::run3$cmd,\undef,($outfile ? $outfile : \$out),\my$err;return ($?,$out,$err)}sub check_makemaker($self) {my$module='ExtUtils::MakeMaker';my$version=EXTUTILS_MAKEMAKER_MIN_VERSION;return 1 if has_module_version($module,$version);WARN("Trying to update ExtUtils::MakeMaker");my$ok=$self->install_single_module($module);if (!$ok){ERROR("Please update ExtUtils::MakeMaker to $version or later");return}return$ok}sub install_single_module ( $self, $module ) {return 1 if$self->tracking_module($module);my$cli=$self->cli or die;my$module_info=$cli->modules_idx->search($module);if (!$module_info){FAIL("Cannot find module '$module'");return}return 1 if has_module_version($module_info->{module},$module_info->{version});my$repository_info=$cli->repositories_idx->search($module_info->{repository},$module_info->{repository_version});if (!$repository_info){FAIL("Cannot find repository for " .$module_info->{repository});return}return$self->install_repository($repository_info)}sub install_repository ( $self, $repository_info ) {die unless ref$repository_info;my$name=$repository_info->{repository};return 1 if$self->tracking_repository($name);INFO("Installing Distribution $name");return unless$self->setup_tarball($repository_info);return unless$self->resolve_dependencies($name);my$BUILD=$self->BUILD->{$name}or die;my$indir=pushd($BUILD->{_rootdir});return unless$self->do_configure($name);return unless$self->do_install($name);DONE("Installed Distribution $name");return 1}sub do_install ( $self, $name ) {{install("Running make for $name");my ($status,$out,$err)=run3("make");if ($status!=0){ERROR("Fail to build $name");WARN($out)if defined$out;ERROR("$err")if defined$out;return}DEBUG("make output:\n$out")}{install("Running Tests for $name");my ($status,$out,$err)=run3("make test");if ($status!=0){ERROR("Test failure from $name");WARN($out)if defined$out;ERROR("$err")if defined$out;return}DEBUG("Test run $name output:\n$out")}{install("succeeds for $name");my ($status,$out,$err)=run3("make install");if ($status!=0){ERROR("Fail to install $name");WARN($out)if defined$out;ERROR("$err")if defined$out;return}DEBUG("Make install output $name:\n$out")}return 1}sub do_configure ( $self, $name ) {my$BUILD=$self->BUILD->{$name}or die;configure("Generate Makefile.PL for $name");$self->generate_makefile_pl($BUILD);configure("Running Makefile.PL for $name");my ($status,$out,$err)=run3("$^X Makefile.PL");if ($status!=0){ERROR("$err");return}return 1}sub generate_makefile_pl ( $self, $BUILD ) {die unless ref$BUILD;my$template=<<'EOS';my%PMs;{my@requires_type=qw{requires_build requires_runtime};for my$type (@requires_type){my$requires_list=$BUILD->{$type}// {};$PMs{$type}='';next unless scalar keys %$requires_list;for my$module (sort keys %$requires_list){my$version=$requires_list->{$module};$PMs{$type}.= "     '" ._sanity($module)."' => $version,\n"}}}open(my$fh,'>','Makefile.PL')or die "Fail to open Makefile.PL $!";my%v=(CPLAY_VERSION=>$App::cplay::VERSION,ABSTRACT=>_sanity($BUILD->{abstract}),AUTHOR=>_sanity($BUILD->{maintainers}->[0]),DISTNAME=>_sanity($BUILD->{name}),LICENSE=>_sanity($BUILD->{license}),PRIMARY=>_sanity($BUILD->{primary}),VERSION=>_sanity($BUILD->{version}),PREREQ_PM=>$PMs{requires_runtime},TEST_REQUIRES=>$PMs{requires_build},);$template =~ s{~([A-Za-z_]+)~}{$v{$1}}g;print {$fh}$template or return;return 1}sub _sanity($str) {$str =~ s{\n}{}g;$str =~ s{'}{\\'}g;return$str}sub resolve_dependencies ( $self, $name ) {my$BUILD=$self->BUILD->{$name}or die;my@order=qw{requires_build requires_runtime};for my$type (@order){my$requires_list=$BUILD->{$type}// {};next unless scalar keys %$requires_list;resolve("$type for $name");for my$module (sort keys %$requires_list){my$version=$requires_list->{$module};resolve("\t$name $type $module v$version");next if has_module_version($module,$version);DEBUG("Module $module v$version is missing");return unless$self->install_single_module($module)}}return 1}sub setup_tarball ( $self, $repository_info ) {my$name=$repository_info->{repository};my$tarball=$self->download_repository($repository_info);my$relative_path=$self->unpacker->unpack($tarball);my$full_path=$self->cli->builddir .'/' .$relative_path;if (!defined$relative_path ||!-d $full_path){FAIL("fail to extract tarball $tarball");return}my$dir=pushd($full_path);my$BUILD;if (-e 'BUILD.json'){eval {$BUILD=$self->json->decode(read_file('BUILD.json'));1}or DEBUG("Fail to read BUILD.json $@")}else {ERROR("Missing BUILD.json file for Distribution $name");return}if (!ref$BUILD){ERROR("Fail to read BUILD.json file from $full_path");return}$BUILD->{_rootdir}=$full_path;$self->BUILD->{$name}=$BUILD;return 1}sub download_repository ( $self, $repository_info ) {my$cli=$self->cli or die;my$url=$cli->repositories_idx->get_tarball_url($repository_info)or die;fetch("$url");my$name=$repository_info->{repository};my$sha=$repository_info->{sha};my$local=$cli->builddir ."/${name}.tar.gz";$cli->http->mirror($url,$local);return$local}sub tracking_module ( $self, $module ) {die unless defined$module;return 1 if$self->{_tracked_modules}->{$module};$self->{_tracked_modules}->{$module}=1;return}sub tracking_repository ( $self, $repository ) {die unless defined$repository;return 1 if$self->{_tracked_repositories}->{$repository};$self->{_tracked_repositories}->{$repository}=1;return}1;
  # This is generated by cplay v~CPLAY_VERSION~
  
  ## ~DISTNAME~ v~VERSION~
  
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  my %WriteMakefileArgs = (
    'ABSTRACT' => '~ABSTRACT~',
    'AUTHOR' => '~AUTHOR~',
    'CONFIGURE_REQUIRES' => {
      'ExtUtils::MakeMaker' => 0
    },
    'DISTNAME' => '~DISTNAME~',
    'LICENSE' => '~LICENSE~',
    'NAME' => '~PRIMARY~',
    'PREREQ_PM' => {
  ~PREREQ_PM~
    },
    'TEST_REQUIRES' => {
  ~TEST_REQUIRES~
    },
    'VERSION' => '~VERSION~',
    'test' => {
      'TESTS' => 't/*.t'
    }
  );
  
  WriteMakefile(%WriteMakefileArgs);
  EOS
APP_CPLAY_INSTALLER

    $fatpacked{"App/cplay/Installer/Unpacker.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INSTALLER_UNPACKER';
  package App::cplay::Installer::Unpacker;use App::cplay::std;use File::Basename ();use File::Temp ();use File::Which ();use IPC::Run3 ();use File::pushd;sub run3 ( $cmd, $outfile = undef ) {my$out;IPC::Run3::run3$cmd,\undef,($outfile ? $outfile : \$out),\my$err;return ($?,$out,$err)}sub new ( $class, %argv ) {my$self=bless \%argv,$class;$self->_init_untar;return$self}sub unpack ( $self, $file ) {my$method=$self->{method}{untar};my$dir;$dir=pushd($self->{tmproot})if$self->{tmproot};return$self->can($method)->($self,$file)}sub _init_untar($self) {my$tar=$self->{tar}=File::Which::which('gtar')|| File::Which::which("tar");if ($tar){my ($exit,$out,$err)=run3 [$tar,'--version' ];$self->{tar_kind}=$out =~ /bsdtar/ ? "bsd" : "gnu";$self->{tar_bad}=1 if$out =~ /GNU.*1\.13/i || $^O eq 'MSWin32' || $^O eq 'solaris' || $^O eq 'hpux'}if ($tar and!$self->{tar_bad}){$self->{method}{untar}=*_untar;return if!$self->{_init_all}}my$gzip=$self->{gzip}=File::Which::which("gzip");my$bzip2=$self->{bzip2}=File::Which::which("bzip2");if ($tar && $gzip && $bzip2){$self->{method}{untar}=*_untar_bad;return if!$self->{_init_all}}if (eval {require Archive::Tar}){$self->{"Archive::Tar"}=Archive::Tar->VERSION;$self->{method}{untar}=*_untar_module;return if!$self->{_init_all}}return if$self->{_init_all};$self->{method}{untar}=sub {die "There is no backend for untar"}}sub _untar ( $self, $file ) {my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? 'j' : 'z';($exit,$out,$err)=run3 [$self->{tar},"${ar}tf",$file ];last if$exit!=0;my$root=$self->_find_tarroot(split /\r?\n/,$out);($exit,$out,$err)=run3 [$self->{tar},"${ar}xf",$file,"-o" ];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_bad ( $self, $file ) {my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? $self->{bzip2}: $self->{gzip};my$temp=File::Temp->new(SUFFIX=>'.tar',EXLOCK=>0);($exit,$out,$err)=run3 [$ar,"-dc",$file ],$temp->filename;last if$exit!=0;my@opt=$^O eq 'MSWin32' && $self->{tar_kind}ne "bsd" ? ('--force-local'): ();($exit,$out,$err)=run3 [$self->{tar},@opt,"-tf",$temp->filename ];last if$exit!=0 ||!$out;my$root=$self->_find_tarroot(split /\r?\n/,$out);($exit,$out,$err)=run3 [$self->{tar},@opt,"-xf",$temp->filename,"-o" ];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_module ( $self, $file ) {my$wantarray=wantarray;no warnings 'once';local$Archive::Tar::WARN=0;my$t=Archive::Tar->new;{my$ok=$t->read($file);last if!$ok;my$root=$self->_find_tarroot($t->list_files);my@file=$t->extract;return$root if@file and -d $root}return if!$wantarray;return (undef,$t->error)}sub _find_tarroot ( $self, $root, @others ) {FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length$root){$root=shift@others;redo FILE if$root}}return$root}1;
APP_CPLAY_INSTALLER_UNPACKER

    $fatpacked{"App/cplay/Logger.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_LOGGER';
  package App::cplay::Logger;use App::cplay::std;use List::Util 'max';use Exporter 'import';our@EXPORT=qw{DONE FAIL WARN INFO DEBUG};our@EXPORT_OK=(@EXPORT,qw(fetch resolve install configure));our$COLOR;our$VERBOSE;our$SHOW_PROGRESS;BEGIN {$COLOR=1 if -t STDIN}use constant COLOR_RED=>31;use constant COLOR_GREEN=>32;use constant COLOR_YELLOW=>33;use constant COLOR_BLUE=>34;use constant COLOR_PURPLE=>35;use constant COLOR_CYAN=>36;use constant COLOR_WHITE=>7;my%color=(resolve=>COLOR_YELLOW,fetch=>COLOR_BLUE,configure=>COLOR_PURPLE,install=>COLOR_CYAN,FAIL=>COLOR_RED,DONE=>COLOR_GREEN,WARN=>COLOR_YELLOW,INFO=>COLOR_GREEN,DEBUG=>COLOR_WHITE,);sub new ( $class, @args ) {return bless {@args},$class}sub log ( $self_or_class, %options ) {my$type=$options{type}|| "";my$message=$options{message};chomp$message;my$optional=$options{optional}? " ($options{optional})" : "";my$result=$options{result};my$is_color=ref$self_or_class ? $self_or_class->{color}: $COLOR;my$verbose=ref$self_or_class ? $self_or_class->{verbose}: $VERBOSE;my$show_progress=ref$self_or_class ? $self_or_class->{show_progress}: $SHOW_PROGRESS;if (!$result){my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);$year += 1900;$mon++;$result=sprintf('[%04d-%02d-%02d %02d:%02d:%02d]',$year,$mon,$mday,$hour,$min,$sec,)}if ($is_color){$type="\e[$color{$type}m$type\e[m" if$type && $color{$type};$result="\e[$color{$result}m$result\e[m" if$result && $color{$result};$optional="\e[1;37m$optional\e[m" if$optional}my$r=$show_progress ? "\r" : "";if ($verbose){$type=$is_color && $type ? sprintf("%-17s",$type): sprintf("%-9s",$type || "");warn$r .sprintf "%d %s %s %s%s\n",$options{pid}|| $$,$result,$type,$message,$optional}else {warn$r .join(" ",$result,$type ? $type : (),$message .$optional)."\n"}return}sub DONE ( $msg, @args ) {return __PACKAGE__->log(type=>'DONE',message=>$msg,@args)}sub DEBUG ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'DEBUG',message=>$msg,@args)}sub FAIL ( $msg, @args ) {return __PACKAGE__->log(type=>'FAIL',message=>$msg,@args)}sub WARN ( $msg, @args ) {return __PACKAGE__->log(type=>'WARN',message=>$msg,@args)}sub INFO ( $msg, @args ) {return __PACKAGE__->log(type=>'INFO',message=>$msg,@args)}sub fetch ( $msg, @args ) {return __PACKAGE__->log(type=>'fetch',message=>$msg,@args)}sub resolve ( $msg, @args ) {return __PACKAGE__->log(type=>'resolve',message=>$msg,@args)}sub configure ( $msg, @args ) {return __PACKAGE__->log(type=>'configure',message=>$msg,@args)}sub install ( $msg, @args ) {return __PACKAGE__->log(type=>'install',message=>$msg,@args)}1;
APP_CPLAY_LOGGER

    $fatpacked{"App/cplay/Module.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_MODULE';
  package App::cplay::Module;use App::cplay::std;use App::cplay::Logger;use Exporter 'import';our@EXPORT=qw(has_module_version);our@EXPORT_OK=(@EXPORT,qw{get_module_version module_updated});my%CACHE;my%GOT;sub has_module_version ( $module, $version ) {if (defined$CACHE{$module}&& defined$CACHE{$module}->{$version}){return$CACHE{$module}->{$version}}$CACHE{$module}//= {};my$has_module=0;my$got_version=get_module_version($module);if (defined$got_version){if ($got_version eq $version){$has_module=1}else {my$version_check=eval qq{ $version > $got_version ? 0 : 1 };if (!defined$version_check){WARN("module $module version is not numeric: $got_version")}elsif ($version_check){$has_module=1}}}DEBUG("has_module $module >= $version ? $has_module [got " .($got_version // '').']');$CACHE{$module}->{$version}=$has_module;return$has_module}sub get_module_version( $module ) {return$GOT{$module}if defined$GOT{$module};my$version;my$out=qx|$^X -e 'eval { require $module; 1 } or die; print eval { \$${module}::VERSION } // 0' 2>&1|;if ($?==0){$version=$out;chomp$version if$version}$GOT{$module}=$version;DEBUG("get_module_version $module = " .($version // ''));return$version}sub module_updated ( $module, $version ) {}sub clear_cache {%CACHE=();%GOT=();return}1;
APP_CPLAY_MODULE

    $fatpacked{"App/cplay/cli.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CLI';
  package App::cplay::cli;use App::cplay::std;use App::cplay ();use App::cplay::Logger;use App::cplay::Http;use App::cplay::cmd::help ();use App::cplay::cmd::install ();use App::cplay::cmd::version ();use App::cplay::Index::Repositories;use App::cplay::Index::Modules;use App::cplay::Index::ExplicitVersions;use Cwd ();use Simple::Accessor qw{name http cwd homedir builddir snapshot cpanfile retry configure_timeout build_timeout test_timeout repositories_idx modules_idx explicit_versions_idx};use File::Path qw(mkpath rmtree);use Getopt::Long qw(:config no_auto_abbrev no_ignore_case bundling);use Pod::Text ();sub build ( $self, %options ) {for my$k (sort keys%options){$self->{$k}=$options{$k}}$self->cwd;return$self}sub _build_cwd {return Cwd::cwd()}sub _build_homedir {$ENV{HOME}or die q[HOME environmenet variable not set]}sub _build_builddir($self) {my$path=$self->cwd .'/.cpbuild';return$path if -d $path;mkpath($path)or die "fail to create .build directory at: $path";return$path}sub DESTROY($self) {if (ref$self && $self->{builddir}&& $self->{cleanup}){my$dir=$self->{builddir};if (-d $dir &&!-l $dir){DEBUG("rmtree .build directory: $dir");File::Path::rmtree($dir)}}}sub _build_cpanfile {return 'cpanfile'}sub _build_retry {1}sub _build_configure_timeout {60}sub _build_build_timeout {3_600}sub _build_test_timeout {1_800}sub _build_http {App::cplay::Http->create}sub _build_repositories_idx($self) {App::cplay::Index::Repositories->new(cli=>$self)}sub _build_modules_idx($self) {App::cplay::Index::Modules->new(cli=>$self)}sub _build_explicit_versions_idx($self) {App::cplay::Index::ExplicitVersions->new(cli=>$self)}sub parse_options ( $self, @opts ) {local@ARGV=@opts;my ($mirror,@resolver,@feature);my$with_option=sub {my$n=shift;("with-$n",\$self->{"with_$n"},"without-$n",sub {$self->{"with_$n"}=0})};GetOptions("color!"=>\($self->{color}),'cleanup!'=>\($self->{cleanup}),"homedir=s"=>\($self->{homedir}),"cpanfile=s"=>\($self->{cpanfile}),"test!"=>sub {$self->{notest}=$_[1]? 0 : 1},"L|local-lib-contained=s"=>\($self->{local_lib}),"g|global"=>\($self->{global}),"mirror=s"=>\$mirror,"v|verbose"=>\($self->{verbose}),"snapshot=s"=>\($self->{snapshot}),"sudo"=>\($self->{sudo}),"mirror-only"=>\($self->{mirror_only}),"dev"=>\($self->{dev}),"retry!"=>\($self->{retry}),"exclude-vendor!"=>\($self->{exclude_vendor}),"configure-timeout=i"=>\($self->{configure_timeout}),"build-timeout=i"=>\($self->{build_timeout}),"test-timeout=i"=>\($self->{test_timeout}),"show-progress!"=>\($self->{show_progress}),"prebuilt!"=>\($self->{prebuilt}),"reinstall"=>\($self->{reinstall}),"static-install!"=>\($self->{static_install}),(map$with_option->($_),qw(requires recommends suggests)),(map$with_option->($_),qw(configure build test runtime develop)),)or exit 1;$self->{homedir}=Cwd::abs_path($self->homedir);$self->{mirror}=$self->normalize_mirror($mirror)if$mirror;$self->{color}=1 if!defined$self->{color}&& -t STDOUT;$self->{show_progress}=1 if!defined$self->{show_progress}&& -t STDOUT;if ($self->{sudo}){!system "sudo",$^X,"-e1" or exit 1}$self->{cleanup}//= 1;$App::cplay::Logger::COLOR=1 if$self->{color};$App::cplay::Logger::VERBOSE=1 if$self->{verbose};$App::cplay::Logger::SHOW_PROGRESS=1 if$self->{show_progress};if (@ARGV && $ARGV[0]eq "-"){$self->{argv}=$self->read_argv_from_stdin;$self->{cpanfile}=undef}else {$self->{argv}=\@ARGV}return$self}sub read_argv_from_stdin {my$self=shift;my@argv;while (my$line=<STDIN>){next if$line !~ /\S/;next if$line =~ /^\s*#/;$line =~ s/^\s*//;$line =~ s/\s*$//;push@argv,split /\s+/,$line}return \@argv}sub normalize_mirror ( $self, $mirror ) {$mirror =~ s{/*$}{/};return$mirror if$mirror =~ m{^https?://};die qq[Invalid mirror: $mirror]}sub get_cmd_sub_for ( $self, $cmd ) {return unless defined$cmd;$cmd =~ s{^-+}{};my$aliases={h=>'help',v=>'version',V=>'version',i=>'install',};$cmd=$aliases->{$cmd}if defined$aliases->{$cmd};return unless$cmd =~ m{^[A-Za-z0-9_]+$};return "App::cplay::cmd::$cmd"->can('run')}sub run ( $self, @argv ) {my$cmd='';my$run;if (scalar@argv){if ($run=$self->get_cmd_sub_for($argv[0])){$cmd=shift@argv}else {$run=$self->get_cmd_sub_for('install');$cmd='install'}}else {$run=$self->get_cmd_sub_for('help');$cmd='help'}die qq[Unknown subcommand '$cmd'] unless defined$run && ref$run eq 'CODE';$self->parse_options(@argv);$cmd =~ s{^-+}{} if$cmd;if ($cmd && $cmd !~ m{^(?:help|version)$}){INFO("Running action '$cmd'")}return$run->($self,$self->{argv}->@*)}sub load_cpanfile {my ($self,$file)=@_;require Module::CPANfile;my$cpanfile=Module::CPANfile->load($file);if (!$self->{mirror}){my$mirrors=$cpanfile->mirrors;if (@$mirrors){$self->{mirror}=$self->normalize_mirror($mirrors->[0])}else {$self->{mirror}=$self->{_default_mirror}}}my$prereqs=$cpanfile->prereqs_with(@{$self->{"feature"}});my@phase=grep$self->{"with_$_"},qw(configure build test runtime develop);my@type=grep$self->{"with_$_"},qw(requires recommends suggests);my$reqs=$prereqs->merged_requirements(\@phase,\@type)->as_string_hash;my (@package,@reinstall);for my$package (sort keys %$reqs){my$option=$cpanfile->options_for_module($package)|| {};my$req={package=>$package,version_range=>$reqs->{$package},dev=>$option->{dev},reinstall=>$option->{git}? 1 : 0,};if ($option->{git}){push@reinstall,$req}else {push@package,$req}}require App::cpm::Resolver::CPANfile;my$resolver=App::cpm::Resolver::CPANfile->new(cpanfile=>$cpanfile,mirror=>$self->{mirror},);(\@package,\@reinstall,$resolver)}1;
APP_CPLAY_CLI

    $fatpacked{"App/cplay/cmd/help.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_HELP';
  package App::cplay::cmd::help;use App::cplay::std;use Pod::Text ();sub run ( $self, @argv ) {my$out;open my$fh,">",\$out;my$f=$INC{'App/cplay.pm'};$f=$0 unless -e $f;print STDERR "### $f\n";Pod::Text->new->parse_from_file($f,$fh);if (defined$out){$out =~ s/^[ ]{6}/    /mg;print STDERR$out}return 0}1;
APP_CPLAY_CMD_HELP

    $fatpacked{"App/cplay/cmd/install.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_INSTALL';
  package App::cplay::cmd::install;use App::cplay::std;use App::cplay::Logger;use App::cplay::Installer;use Test::More;sub run ( $self, @modules ) {return unless scalar@modules;my$installer=App::cplay::Installer->new(cli=>$self);return unless$installer->check_makemaker();for my$module (@modules){INFO("Looking for module: $module");return unless$installer->install_single_module($module)}return 1}1;
APP_CPLAY_CMD_INSTALL

    $fatpacked{"App/cplay/cmd/version.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_VERSION';
  package App::cplay::cmd::version;use App::cplay::std;sub run ( $self, @argv ) {say "cplay $App::cplay::VERSION ($0)";return}1;
APP_CPLAY_CMD_VERSION

    $fatpacked{"App/cplay/std.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_STD';
  package App::cplay::std;use strict;use warnings;sub import {warnings->import();strict->import();require feature;feature->import(':5.20');feature->import('signatures');warnings->unimport('experimental::signatures');return}1;
APP_CPLAY_STD

    $fatpacked{"Exporter.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'EXPORTER';
  package Exporter;require 5.006;our$Debug=0;our$ExportLevel=0;our$Verbose ||= 0;our$VERSION='5.74';our (%Cache);sub as_heavy {require Exporter::Heavy;my$c=(caller(1))[3];$c =~ s/.*:://;\&{"Exporter::Heavy::heavy_$c"}}sub export {goto &{as_heavy()}}sub import {my$pkg=shift;my$callpkg=caller($ExportLevel);if ($pkg eq "Exporter" and @_ and $_[0]eq "import"){*{$callpkg."::import"}=\&import;return}my$exports=\@{"$pkg\::EXPORT"};my$fail=${$pkg .'::'}{EXPORT_FAIL}&& \@{"$pkg\::EXPORT_FAIL"};return export$pkg,$callpkg,@_ if$Verbose or $Debug or $fail && @$fail > 1;my$export_cache=($Cache{$pkg}||= {});my$args=@_ or @_=@$exports;if ($args and not %$export_cache){s/^&//,$export_cache->{$_}=1 foreach (@$exports,@{"$pkg\::EXPORT_OK"})}my$heavy;if ($args or $fail){($heavy=(/\W/ or $args and not exists$export_cache->{$_}or $fail and @$fail and $_ eq $fail->[0]))and last foreach (@_)}else {($heavy=/\W/)and last foreach (@_)}return export$pkg,$callpkg,($args ? @_ : ())if$heavy;local$SIG{__WARN__}=sub {require Carp;&Carp::carp}if not $SIG{__WARN__};*{"$callpkg\::$_"}=\&{"$pkg\::$_"}foreach @_}sub export_fail {my$self=shift;@_}sub export_to_level {goto &{as_heavy()}}sub export_tags {goto &{as_heavy()}}sub export_ok_tags {goto &{as_heavy()}}sub require_version {goto &{as_heavy()}}1;
EXPORTER

    $fatpacked{"Exporter/Heavy.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'EXPORTER_HEAVY';
  package Exporter::Heavy;use strict;no strict 'refs';require Exporter;our$VERSION=$Exporter::VERSION;sub _rebuild_cache {my ($pkg,$exports,$cache)=@_;s/^&// foreach @$exports;@{$cache}{@$exports}=(1)x @$exports;my$ok=\@{"${pkg}::EXPORT_OK"};if (@$ok){s/^&// foreach @$ok;@{$cache}{@$ok}=(1)x @$ok}}sub heavy_export {my$oldwarn=$SIG{__WARN__};local$SIG{__WARN__}=sub {local$SIG{__WARN__}=$oldwarn;my$text=shift;if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//){require Carp;local$Carp::CarpLevel=1;Carp::carp($text)}else {warn$text}};local$SIG{__DIE__}=sub {require Carp;local$Carp::CarpLevel=1;Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")if $_[0]=~ /^Unable to create sub named "(.*?)::"/};my($pkg,$callpkg,@imports)=@_;my($type,$sym,$cache_is_current,$oops);my($exports,$export_cache)=(\@{"${pkg}::EXPORT"},$Exporter::Cache{$pkg}||= {});if (@imports){if (!%$export_cache){_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (grep m{^[/!:]},@imports){my$tagsref=\%{"${pkg}::EXPORT_TAGS"};my$tagdata;my%imports;my($remove,$spec,@names,@allexports);unshift@imports,':DEFAULT' if$imports[0]=~ m/^!/;for$spec (@imports){$remove=$spec =~ s/^!//;if ($spec =~ s/^://){if ($spec eq 'DEFAULT'){@names=@$exports}elsif ($tagdata=$tagsref->{$spec}){@names=@$tagdata}else {warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];++$oops;next}}elsif ($spec =~ m:^/(.*)/$:){my$patn=$1;@allexports=keys %$export_cache unless@allexports;@names=grep(/$patn/,@allexports)}else {@names=($spec)}warn "Import ".($remove ? "del":"add").": @names " if$Exporter::Verbose;if ($remove){for$sym (@names){delete$imports{$sym}}}else {@imports{@names}=(1)x @names}}@imports=keys%imports}my@carp;for$sym (@imports){if (!$export_cache->{$sym}){if ($sym =~ m/^\d/){$pkg->VERSION($sym);if (@imports==1){@imports=@$exports;last}if (@imports==2 and!$imports[1]){@imports=();last}}elsif ($sym !~ s/^&// ||!$export_cache->{$sym}){unless ($cache_is_current){%$export_cache=();_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (!$export_cache->{$sym}){push@carp,qq["$sym" is not exported by the $pkg module];$oops++}}}}if ($oops){require Carp;Carp::croak(join("\n",@carp,"Can't continue after import errors"))}}else {@imports=@$exports}my($fail,$fail_cache)=(\@{"${pkg}::EXPORT_FAIL"},$Exporter::FailCache{$pkg}||= {});if (@$fail){if (!%$fail_cache){my@expanded=map {/^\w/ ? ($_,'&'.$_): $_}@$fail;warn "${pkg}::EXPORT_FAIL cached: @expanded" if$Exporter::Verbose;@{$fail_cache}{@expanded}=(1)x @expanded}my@failed;for$sym (@imports){push(@failed,$sym)if$fail_cache->{$sym}}if (@failed){@failed=$pkg->export_fail(@failed);for$sym (@failed){require Carp;Carp::carp(qq["$sym" is not implemented by the $pkg module ],"on this architecture")}if (@failed){require Carp;Carp::croak("Can't continue after import errors")}}}warn "Importing into $callpkg from $pkg: ",join(", ",sort@imports)if$Exporter::Verbose;for$sym (@imports){(*{"${callpkg}::$sym"}=\&{"${pkg}::$sym"},next)unless$sym =~ s/^(\W)//;$type=$1;no warnings 'once';*{"${callpkg}::$sym"}=$type eq '&' ? \&{"${pkg}::$sym"}: $type eq '$' ? \${"${pkg}::$sym"}: $type eq '@' ? \@{"${pkg}::$sym"}: $type eq '%' ? \%{"${pkg}::$sym"}: $type eq '*' ? *{"${pkg}::$sym"}: do {require Carp;Carp::croak("Can't export symbol: $type$sym")}}}sub heavy_export_to_level {my$pkg=shift;my$level=shift;(undef)=shift;my$callpkg=caller($level);$pkg->export($callpkg,@_)}sub _push_tags {my($pkg,$var,$syms)=@_;my@nontag=();my$export_tags=\%{"${pkg}::EXPORT_TAGS"};push(@{"${pkg}::$var"},map {$export_tags->{$_}? @{$export_tags->{$_}}: scalar(push(@nontag,$_),$_)}(@$syms)? @$syms : keys %$export_tags);if (@nontag and $^W){require Carp;Carp::carp(join(", ",@nontag)." are not tags of $pkg")}}sub heavy_require_version {my($self,$wanted)=@_;my$pkg=ref$self || $self;return ${pkg}->VERSION($wanted)}sub heavy_export_tags {_push_tags((caller)[0],"EXPORT",\@_)}sub heavy_export_ok_tags {_push_tags((caller)[0],"EXPORT_OK",\@_)}1;
EXPORTER_HEAVY

    $fatpacked{"JSON/PP.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'JSON_PP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::PP::ISA=('Exporter')}use overload ();use JSON::PP::Boolean;use Carp ();$JSON::PP::VERSION='4.04';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true;return ($false,$true)}else {delete$self->{false};delete$self->{true};return}}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($props->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){if (!$relaxed or $ch ne "\t"){$at--;decode_error('invalid character encountered while parsing JSON string')}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::PP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> 0x20){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20"){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_PP

    $fatpacked{"JSON/PP/Boolean.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::PP::Boolean::VERSION='4.04';1;
JSON_PP_BOOLEAN

    $fatpacked{"Simple/Accessor.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'SIMPLE_ACCESSOR';
  package Simple::Accessor;$Simple::Accessor::VERSION='1.11';use strict;use warnings;sub import {my ($class,@attr)=@_;my$from=caller();_add_new($from);_add_accessors(to=>$from,attributes=>\@attr)}sub _add_new {my$class=shift;return unless$class;my$new=$class .'::new';{no strict 'refs';*$new=sub {my ($class,%opts)=@_;my$self=bless {},$class;map {eval {$self->$_($opts{$_})}}keys%opts;if ($self->can('_before_build')){$self->_before_build(%opts)}for my$init ('build','initialize'){if ($self->can($init)){return unless$self->$init(%opts)}}if ($self->can('_after_build')){$self->_after_build(%opts)}return$self}}}sub _add_accessors {my (%opts)=@_;return unless$opts{to};my@attributes=@{$opts{attributes}};return unless@attributes;for my$att (@attributes){my$accessor=$opts{to}."::$att";no strict 'refs';*$accessor=sub {my ($self,$v)=@_;if (defined$v){for (qw{before validate set after}){if ($_ eq 'set'){$self->{$att}=$v;next}my$sub='_' .$_ .'_' .$att;if ($self->can($sub)){return unless$self->$sub($v)}}}elsif (!defined$self->{$att}){for my$builder (qw{build initialize}){my$sub='_' .$builder .'_' .$att;if ($self->can($sub)){return$self->{$att}=$self->$sub()}}}return$self->{$att}}}@attributes=()}1;
SIMPLE_ACCESSOR

    s/^  //mg for values %fatpacked;

    my $class = 'FatPacked::' . ( 0 + \%fatpacked );
    no strict 'refs';
    *{"${class}::files"} = sub { keys %{ $_[0] } };

    if ( $] < 5.008 ) {
        *{"${class}::INC"} = sub {
            if ( my $fat = $_[0]{ $_[1] } ) {
                my $pos  = 0;
                my $last = length $fat;
                return (
                    sub {
                        return 0 if $pos == $last;
                        my $next = ( 1 + index $fat, "\n", $pos ) || $last;
                        $_ .= substr $fat, $pos, $next - $pos;
                        $pos = $next;
                        return 1;
                    }
                );
            }
        };
    }

    else {
        *{"${class}::INC"} = sub {
            if ( my $fat = $_[0]{ $_[1] } ) {
                open my $fh, '<', \$fat
                  or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
                return $fh;
            }
            return;
        };
    }

    unshift @INC, bless \%fatpacked, $class;
}    # END OF FATPACK CODE

use strict;
use warnings;

use App::cplay::cli ();

unless (caller) {
    exit( App::cplay::cli->new( name => "App::cplay" )->run(@ARGV) // 0 );
}

1;

### DO NOT EDIT POD HERE, adjuts cplay.pm
## __CPLAY_POD_MARKER__

=encoding utf8

=head1 NAME

App::cplay -  CPAN client using pause-play indexes

=head1 SYNOPSIS

    # Install one ore more distribution [using module or distribution names]
    cplay Cwd
    cplay Cwd File::Copy
    cplay Path-Tools

    cplay install Cwd
    cplay install Cwd File::Copy

    # install a custom or trial version
    cplay install Devel-PPPort@3.57_02

    # preserve .cpbuild directory to preserve cache and debug
    cplay install --no-cleanup --verbose A1z::Html

    # install distributions from a cpanfile
    cplay cpanfile .
    cplay cpanfile ~/my-custom.cpanfile

    cplay --version
    cplay --help

Run C<cplay -h> or C<perldoc cplay> for more options.

=head1 DESCRIPTION

This repository provides the `cplay` client to install Perl modules without using PAUSE.
This is using the `pause-play` GitHub repositories indexed by `pause-index`

[https://pause-play.github.io/pause-index/](https://pause-play.github.io/pause-index/)

Rather than using distribution tarball from PAUSE itself, `play` is relying on GitHub infrastructure to download distributions.

The repo `pause-index` host some index files which can be consumed to download and install most Perl modules.

`cplay` is the recommended CPAN client using these indexes and GitHub repositories.
You can read more about cplay client on the [cplay website](https://pause-play.github.io/cplay/).

=head1 INSTALLATION

=head2 Package management system

...

=head2 Installing to system perl

...

=head1 How to use cplay

=head2 Install a Perl Module

   # install a single module
   cplay A1z::Html
   cplay install A1z::Html
   cplay install --verbose A1z::Html

   # install multiple modules
   cplay First::Module Second::Module ...

   # install a custom version
   cplay A1z::Html@0.04

   # install a trial version
   cplay Devel::PPPort@3.57_02

=head2 Install a Perl distribution

You could use either a module name or a distribution name.

   # install a single distribution
   cplay A1z-Html
   cplay install A1z-Html
   cplay install --verbose A1z-Html

   # install multiple modules
   cplay First-Distribution Second-Distribution

   # install a custom version
   cplay A1z-Html@0.04

   # install a trial version
   cplay Devel-PPPort@3.57_02

=head2 Mix Perl modules and distributions

   cplay Module::Name Distribution-Name ...

=head2 Install Perl Modules from a cpanfile

    cplay cpanfile .
    cplay cpanfile ~/path-to/my-custom.cpanfile

=head2 Install a development or TRIAL version

   # install a trial version
   cplay Devel::PPPort@3.57_02
   cplay Devel-PPPort@3.57_02

=head2 Install a module from a custom repository

   cplay --from-tarball ./path-to/custom.tar.gz
   # where :owner, :repository and :sha are replaced with the accurate values
   cplay --from-tarball https://github.com/:owner/:repository/archive/:sha.tar.gz

=head1 Available options when installing a distribution

   --no-cleanup     preserve the .cpbuild directory
   --verbose        display more output
   --debug


=head1 Developer guide

=head2 Install dependencies

=head2 Build the fatpack version

=head1 Known issues

Probably a lot at this point this is still in active development.

=head1 TODO

=over 4

=item * [ ] setup GitHub pages

=item * [ ] support for cpanfiles

=item * [ ] write some pod/doc

=item * [ ] write some tests

=item * [ ] download the .idx tarball rather than the files themselves

=item * [ ] check the .idx signature

=item * [ ] purge .idx older than X hours

=item * [ ] prefer a quick file read/scan?

=item * [ ] log output to file

=item * [ ] improve IPC::run3 and isolate it to its own module

=item * [ ] ability to download trial version    Module@1.1_0001

=item * [ ] ability to download a custom version Module@1.3

=item * [ ] better detection of make / gmake

=item * [ ] check tarball signature

=back

=head1 DEPENDENCIES

...

=head1 QUESTIONS

=head2 Something?

Answer

=head1 COPYRIGHT

Copyright 2020 - Nicolas R.

The standalone executable contains the following modules embedded.

=over 4

=item L<HTTP::Tiny> Copyright 2011 Christian Hansen

=item L<JSON::PP> Copyright 2007-2011 by Makamaka Hannyaharamitu

=item L<File::pushd> Copyright 2012 David Golden

=item L<parent> Copyright (c) 2007-10 Max Maischein

=back

=head1 LICENSE

This software is licensed under the same terms as Perl.

=head1 CREDITS

=head2 CONTRIBUTORS

Patches and code improvements were contributed by:

...

=head2 ACKNOWLEDGEMENTS

Bug reports, suggestions and feedbacks were sent by, or general
acknowledgement goes to:

....

=head1 NO WARRANTY

This software is provided "as-is," without any express or implied
warranty. In no event shall the author be held liable for any damages
arising from the use of the software.

=head1 SEE ALSO

Also consider using traditional CPAN Clients, relying on PAUSE index:

=over 4

=item * L<App::cpm> - a fast CPAN moduler installer

=item * L<App:cpanm> - get, unpack, build and install modules from CPAN

=item * L<CPAN> - the traditional CPAN client

=item * L<CPANPLUS>

=item * L<pip>

=back

=cut

## __CPLAY_POD_MARKER__

__END__

TODO

- support for cpanfile
- support for sudo
