#!/usr/bin/env perl

package main;

our $SOURCE_CODE;

BEGIN {    # thanks to mst and shadowcat to read itself
    if ( grep { m{self-?install} } @ARGV ) {
        require Filter::Util::Call;    #  CORE from 5.8

        $SOURCE_CODE = qq[#!$^X\n\n];  # set the shebang

        Filter::Util::Call::filter_add(
            sub {
                Filter::Util::Call::filter_del();
                1 while Filter::Util::Call::filter_read();
                $SOURCE_CODE .= $_;
                return 1;
            }
        );
    }
}

BEGIN {
    if ( "$]" < 5.019 ) {    # needs 5.20 for function signature
        die <<"EOS";
$0 is not supported on Perl $]
	cplay needs Perl 5.20 or higher
	please consider alternate solutions such as App::cpanminus or App::cpm
EOS
    }
}

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
    my %fatpacked;

    $fatpacked{"App/cplay.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY';
  package App::cplay;our$VERSION="0.0001";our$REVISION='cf648a8';1;
APP_CPLAY

    $fatpacked{"App/cplay/BUILD.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_BUILD';
  package App::cplay::BUILD;use App::cplay::std;use App::cplay::Logger;use App::cplay::Helpers qw{read_file write_file};use Cwd ();use File::Basename ();use constant IN_JSON=>qw{abstract builder builder_API_version license maintainers name no_index primary provides recommends_runtime requires_build requires_develop requires_runtime scripts source version tests xs};use Simple::Accessor +IN_JSON,qw{_rootdir _filepath};with 'App::cplay::Roles::JSON';sub build ( $self, %options ) {$self->builder_API_version($self->builder_API_version);$self->builder(lc($options{builder}// $self->builder));if (!defined$self->name ||!length$self->name){ERROR("missing name");return}if (!defined$self->version){ERROR("missing version for " .$self->name);return}return$self}sub _build_xs {0}sub _build_builder {'play'}sub _build_builder_API_version {1}sub _build_license {'perl'}sub _build_source {'p5'}sub _build_version {'0.001'}sub _build_tests {['t/*.t']}sub _build_maintainers {[]}sub _build_provides {{}}sub _build_recommends_runtime {{}}sub _build_requires_build {{}}sub _build_requires_develop {{}}sub _build_requires_runtime {{}}sub _build_scripts {[]}sub bin($self) {return$self->scripts}sub _validate_builder ( $self, $v ) {return 1 if$v && $v =~ m{^(?:play|makefile\.pl|build\.pl)$};die 'Invalid builder ' .($v // 'undef')}sub _validate_builder_API_version ( $self, $v ) {return 1 if$v && $v==1;die "Invalid builder_API_version " .($v // 'undef');return}sub save_to_file ( $self, $file = 'BUILD.json' ) {my$json=$self->json->pretty(1)->encode($self->as_hash);return eval {write_file($file,$json);1}}sub as_hash($self) {for my$attr (IN_JSON){$self->can($attr)->($self)}my%as_hash=map {$_=>$self->{$_}}IN_JSON;if ($as_hash{tests}&& scalar @{$as_hash{tests}}==1 && $as_hash{tests}->[0]eq 't/*.t'){delete$as_hash{tests}}delete$as_hash{no_index}unless defined$as_hash{no_index};return \%as_hash}sub create_from_file($file='BUILD.json') {state$JSON=App::cplay::Roles::JSON->new;$file=Cwd::abs_path($file);my$json;if (-e $file){eval {$json=$JSON->json->decode(read_file($file,':utf8'));1}or eval {$json=$JSON->json->decode(read_file($file,''));1}or DEBUG("Fail to read $file $@")}else {ERROR("Missing file $file");return}if (!ref$json){ERROR("Fail to read BUILD.json file $file");return}my$_rootdir=File::Basename::dirname($file);return App::cplay::BUILD->new(%$json,_rootdir=>$_rootdir,_filepath=>$file)}1;
APP_CPLAY_BUILD

    $fatpacked{"App/cplay/Helpers.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_HELPERS';
  package App::cplay::Helpers;use App::cplay::std;use Config;use File::Which ();use App::cplay::Logger;use Exporter 'import';our@EXPORT_OK=qw(read_file zip write_file is_fatpacked update_shebang);sub read_file ( $file, $mode = ':utf8' ) {local $/;open(my$fh,'<' .$mode,$file)or die "Fail to open file: $! " .join(' ',(caller(1))[0,1,2,3 ])."\n";return readline($fh)}sub is_fatpacked() {return unless my$ref=ref$INC{'App/cplay/cmd/selfinstall.pm'};return$ref =~ m{^FatPacked} ? 1 : 0}sub write_file ( $file, $content, $mode = ':utf8' ) {open(my$fh,'>' .$mode,$file)or die "Fail to open file: '$file' $! " .join(' ',(caller(1))[0,1,2,3 ])."\n";print {$fh}$content;return}sub zip : prototype(\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {my$max=-1;$max < $#$_ && ($max=$#$_)foreach @_;map {my$ix=$_;map $_->[$ix],@_}0 .. $max}sub make_binary {my@lookup=($Config{make},qw{make gmake});for my$bin (@lookup){next unless$bin;my$path=File::Which::which($Config{make});next unless -x $path;no warnings 'redefine';*make_binary=sub {$path};return$path}FATAL("Cannot find make binary")}sub prove_binary {my$prove;my@prefixes=qw{bin installbin sitebin vendorbin};for my$prefix (@prefixes){next unless$Config{$prefix};$prove=$Config{$prefix}.'/prove';last if -x $prove}if (!-x $prove){my$perldoc=$^X ."doc";$prove=qx{$perldoc -l prove};$prove=undef if $?!=0}if (defined$prove && -x $prove){no warnings 'redefine';*prove_binary=sub {$prove};return$prove}FATAL("Cannot find 'prove' binary")}sub update_shebang($file) {return unless defined$file && -f $file;open(my$input,'<',$file)or die "Fail to open file: $! " .join(' ',(caller(1))[0,1,2,3 ])."\n";my$output_file="$file.tmp";open(my$output,'>',$output_file)or die "Fail to open file: $! " .join(' ',(caller(1))[0,1,2,3 ])."\n";my$c=0;while (my$line=<$input>){if (++$c==1 && $line =~ m{^#!.*perl}){$line=qq[#!$^X]}print {$output}$line}return}1;
APP_CPLAY_HELPERS

    $fatpacked{"App/cplay/Http.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_HTTP';
  package App::cplay::Http;use App::cplay::std;use App::cplay ();use HTTP::Tinyish;sub create ( $class, %args ) {my@try=$args{prefer}? @{$args{prefer}}: qw(HTTPTiny LWP Curl Wget);my ($backend,$tool,$desc);for my$try (map "HTTP::Tinyish::$_",@try){my$meta=HTTP::Tinyish->configure_backend($try)or next;$try->supports("https")or next;($tool)=sort keys %$meta;($desc=$meta->{$tool})=~ s/^(.*?)\n.*/$1/s;$backend=$try,last}die "Couldn't find HTTP Clients that support https" unless$backend;my$http=$backend->new(agent=>"App::cplay/v" .$App::cplay::VERSION,timeout=>60,verify_SSL=>1,%args,);my$keep_alive=exists$args{keep_alive}? $args{keep_alive}: 1;if ($keep_alive and $backend =~ /LWP$/){$http->{ua}->conn_cache({total_capacity=>1 })}return$http}1;
APP_CPLAY_HTTP

    $fatpacked{"App/cplay/IPC.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_IPC';
  package App::cplay::IPC;use App::cplay::std;use App::cplay::Logger qw{RUN DEBUG STDERROR};use IPC::Run3 ();sub run3 ( $cmd ) {my ($out,$err);{my$oneliner=ref$cmd ? join(' ',@$cmd): $cmd;RUN($oneliner)}IPC::Run3::run3($cmd,\undef,_output(\$out),_error(\$err));return ($?,$out,$err)}sub _output($r_str) {return sub($line) {DEBUG($line);$$r_str='' unless defined $$r_str;$$r_str .= $line;return}}sub _error($r_str) {return sub($line) {STDERROR($line);$$r_str='' unless defined $$r_str;$$r_str .= $line;return}}1;
APP_CPLAY_IPC

    $fatpacked{"App/cplay/Index.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INDEX';
  package App::cplay::Index;use App::cplay::std;use App::cplay::Logger;use App::cplay::Installer::Unpacker ();use constant BASE_URL=>q[https://pause-play.github.io/pause-index];use constant IDX_TARBALL_URL=>q[https://github.com/pause-play/pause-index/archive/p5.tar.gz];use constant MODULES_IX_BASENAME=>'module.idx';use constant REPOSITORIES_IX_BASENAME=>'repositories.idx';use constant EXPLICIT_VERSIONS_IX_BASENAME=>'explicit_versions.idx';use constant REFRESH_TIMEOUT=>24 * 3_600;my$_MODULES_IX_FILE;my$_REPOSITORIES_IX_FILE;my$_EXPLICIT_VERSIONS_IX_FILE;sub setup_once ( $cli, $attempt = 1 ) {no warnings 'redefine';ref$cli eq 'App::cplay::cli' or die "cli is not one App::cplay: $cli";my$root=$cli->cache_dir;$_MODULES_IX_FILE="$root/" .MODULES_IX_BASENAME;$_REPOSITORIES_IX_FILE="$root/" .REPOSITORIES_IX_BASENAME;$_EXPLICIT_VERSIONS_IX_FILE="$root/" .EXPLICIT_VERSIONS_IX_BASENAME;my@all_ix_files_basename=(MODULES_IX_BASENAME,REPOSITORIES_IX_BASENAME,EXPLICIT_VERSIONS_IX_BASENAME);my@all_ix_files=($_MODULES_IX_FILE,$_REPOSITORIES_IX_FILE,$_EXPLICIT_VERSIONS_IX_FILE);my$now=time;INFO("Check and refresh cplay index files.");my$force_refresh=$cli->refresh;if (!$force_refresh){for my$file (@all_ix_files){if (!-e $file){$force_refresh=1;last}my$mtime=(stat($file))[9];if (($now - $mtime)> REFRESH_TIMEOUT){DEBUG("clearing index file $file");unlink($file);$force_refresh=1}}}if ($force_refresh){my$http=$cli->http;my$ix_tarball=$cli->cache_dir .'/p5.tar.gz';unlink$ix_tarball if$attempt > 1;App::cplay::Logger::fetch(IDX_TARBALL_URL);$http->mirror(IDX_TARBALL_URL,$ix_tarball);my$unpacker=App::cplay::Installer::Unpacker->new(tmproot=>$cli->build_dir);my$cd=$cli->cache_dir;my$relative_path=$unpacker->unpack($ix_tarball);FATAL("Fail to extra index tarball: " .IDX_TARBALL_URL)unless defined$relative_path;require File::Copy;for my$f (@all_ix_files_basename){my$tmp=$cli->build_dir .'/' .$relative_path .'/' .$f;FATAL("File '$f' is not part of tarball " .IDX_TARBALL_URL)unless -f $tmp;File::Copy::move($tmp,"$root/$f")or FATAL("Fail to move index file '$f' to '$root/$f'")}}if (!_check_file_versions(@all_ix_files)){if ($attempt >= 2){FATAL("index files versions mismatch")}else {map {unlink $_}@all_ix_files;return setup_once($cli,$attempt + 1)}}*setup_once=sub {};return}sub _check_file_versions(@files) {FATAL("Need at least two files")if scalar@files < 2;my$use_version;for my$file (@files){if (open(my$fh,'<:utf8',$file)){my$has_version;while (my$line=<$fh>){if ($line =~ m{"version"\s*:\s*(\w+)\s*,}){$has_version=1;my$v=$1;if (!defined$use_version){$use_version=$v}elsif ($v ne $use_version){WARN("file version mismatch: $file");return}last}}FATAL(qq[Cannot find "version" in index file: $file])unless$has_version}}return 1}sub get_modules_ix_file($cli) {setup_once($cli);return$_MODULES_IX_FILE}sub get_repositories_ix_file($cli) {setup_once($cli);return$_REPOSITORIES_IX_FILE}sub get_explicit_versions_ix_file($cli) {setup_once($cli);return$_EXPLICIT_VERSIONS_IX_FILE}1;
APP_CPLAY_INDEX

    $fatpacked{"App/cplay/Index/ExplicitVersions.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INDEX_EXPLICITVERSIONS';
  package App::cplay::Index::ExplicitVersions;use App::cplay::std;use App::cplay::Index;use App::cplay::Logger;use App::cplay::Helpers qw{zip};use Simple::Accessor qw{file cli template_url};with 'App::cplay::Roles::JSON';with 'App::cplay::Index::Role::Columns';sub build ( $self, %opts ) {$self->{file}=App::cplay::Index::get_explicit_versions_ix_file($self->cli);return$self}sub _build_template_url($self) {...}sub search ( $self, $repository_or_module, $version = undef, $can_be_module = 1, $can_be_repo = 1, ) {return unless$can_be_repo || $can_be_module;INFO("explicit versions search for $repository_or_module / " .($version // 'undef'));my$module_ix=$self->columns->{module};my$version_ix=$self->columns->{version};my$repository_ix=$self->columns->{repository};my$repository_version_ix=$self->columns->{repository_version};open(my$fh,'<:utf8',$self->file)or die "Cannot open ExplicitVersions files: $!";my$in_data;while (my$line=<$fh>){if (!$in_data){$in_data=1 if$line =~ m{^\s*"data"};next}next unless$line =~ m{^\s*\[};$line =~ s{,\s*$}{};my$raw;eval {$raw=$self->json->decode($line)};my$found;if ($can_be_module && $raw->[$module_ix]eq $repository_or_module){if (!defined$version || $version eq $raw->[$version_ix]){$found=1}}elsif ($can_be_repo && $raw->[$repository_ix]eq $repository_or_module){if (!defined$version || $version eq $raw->[$repository_version_ix]){$found=1}}if ($found){return {zip(@{$self->sorted_columns},@$raw)}}}return}1;
APP_CPLAY_INDEX_EXPLICITVERSIONS

    $fatpacked{"App/cplay/Index/Modules.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INDEX_MODULES';
  package App::cplay::Index::Modules;use App::cplay::std;use App::cplay::Index;use App::cplay::Helpers qw{read_file zip};use App::cplay::Logger;use Simple::Accessor qw{file cli cache};with 'App::cplay::Roles::JSON';with 'App::cplay::Index::Role::Columns';sub build ( $self, %opts ) {$self->{file}=App::cplay::Index::get_modules_ix_file($self->cli);return$self}sub _build_cache($self) {return$self->json->decode(read_file($self->file))}sub search ( $self, $module, $version = undef ) {FATAL("Missing module")unless defined$module;INFO("search module $module");return unless my$cache=$self->cache;my$ix=$self->columns->{module};for my$raw (@{$cache->{data}}){if ($raw->[$ix]eq $module){if (defined$version){my$v_ix=$self->columns->{version};if ($raw->[$v_ix]ne $version){DEBUG("requested $module version $version ; latest is " .$raw->[$v_ix]);return}}return {zip(@{$cache->{columns}},@$raw)}}}return}sub quick_search ( $self, $module ) {}1;
APP_CPLAY_INDEX_MODULES

    $fatpacked{"App/cplay/Index/Repositories.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INDEX_REPOSITORIES';
  package App::cplay::Index::Repositories;use App::cplay::std;use App::cplay::Index;use App::cplay::Helpers qw{read_file zip};use App::cplay::Logger;use Simple::Accessor qw{file cli cache template_url};with 'App::cplay::Roles::JSON';with 'App::cplay::Index::Role::Columns';sub build ( $self, %opts ) {$self->{file}=App::cplay::Index::get_repositories_ix_file($self->cli);return$self}sub _build_cache($self) {return$self->json->decode(read_file($self->file))}sub _build_template_url($self) {$self->cache->{template_url}or die}sub search ( $self, $repository, $version = undef ) {INFO("search repository $repository / " .($version // 'undef'));return unless my$cache=$self->cache;my$repository_ix=$self->columns->{repository};my$version_ix=$self->columns->{version};for my$raw (@{$cache->{data}}){next unless$raw->[$repository_ix]eq $repository;if (!defined$version || $version eq $raw->[$version_ix]){return {zip(@{$cache->{columns}},@$raw)}}return}return}sub get_tarball_url ( $self, $repository ) {die unless ref$repository;my$url=$self->template_url;$url =~ s{:([a-z0-9]+)}{$repository->{$1}}g;return$url}sub get_git_repository_url ( $self, $repository ) {die unless ref$repository;my$url=$self->template_url;($url,undef)=split('/archive',$url);$url .= '.git';$url =~ s{:([a-z0-9]+)}{$repository->{$1}}g;return$url}1;
APP_CPLAY_INDEX_REPOSITORIES

    $fatpacked{"App/cplay/Index/Role/Columns.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INDEX_ROLE_COLUMNS';
  package App::cplay::Index::Role::Columns;use App::cplay::std;use App::cplay::Logger;use Simple::Accessor qw{columns sorted_columns};sub _build_columns($self) {open(my$fh,'<:utf8',$self->file)or die "Cannot open ExplicitVersions files: $!";my$columns={};my$ix=0;my$description;while (my$line=<$fh>){next unless$line =~ m{^\s*"columns"};$line =~ s{,\s*$}{};$line="{ $line }";eval {$description=$self->json->decode($line)};last}if (!$description ||!$description->{columns}){FATAL("Cannot read columns definition for ExplicitVersions index file")}for my$name (@{$description->{columns}}){$columns->{$name}=$ix++}return$columns}sub _build_sorted_columns($self) {my$columns=$self->columns;my$sorted=[];for my$k (keys %$columns){$sorted->[$columns->{$k}]=$k}return$sorted}1;
APP_CPLAY_INDEX_ROLE_COLUMNS

    $fatpacked{"App/cplay/InstallDirs.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INSTALLDIRS';
  package App::cplay::InstallDirs;use App::cplay::std;use App::cplay::Logger;use App::cplay::IPC;use Config;use File::Path;use Simple::Accessor qw{type arch lib bin script man1 man3};my$IX={arch=>0,lib=>1,bin=>2,script=>3,man1=>4,man3=>5 };my$MAP={perl=>[qw{installarchlib installprivlib installbin installscript installman1dir installman3dir} ],site=>[qw{installsitearch installsitelib installsitebin installsitescript installsiteman1dir installsiteman3dir} ],vendor=>[qw{installvendorarch installvendorlib installvendorbin installvendorscript installvendorman1dir installvendorman3dir} ],};sub _get_config {return \%Config}sub build ( $self, %options ) {my$type=delete$options{type}// 'site';$self->type($type);if (scalar keys%options){die q[Too many arguments to new: ] .join(', ',sort keys%options)}my$cfg=_get_config();for my$k (keys %$IX){my$name=$MAP->{$type}->[$IX->{$k}];$self->{$k}=$cfg->{$name}}return$self}sub _validate_type ( $self, $v ) {return 1 if defined$v && defined$MAP->{$v};FATAL('Invalid type ' .($v // 'undef'))}sub create_if_missing ( $self, $dir ) {FATAL("dir is not defined")unless defined$dir && length$dir;if (!-d $dir){DEBUG("Creating missing directory: $dir");File::Path::make_path($dir,{chmod=>0755,verbose=>0 })or FATAL("Fail to create $dir")}return}sub adjust_perl_shebang ( $self, $file, $perl = $^X ) {my$shebang;open(my$input,'<',$file)or do {WARN("Fail to open $file");return};$shebang=readline$input;chomp$shebang if defined$shebang;my$original_shebang=$shebang;return unless$shebang =~ s{^#![/\w\.\-_]*\s*perl\s*$}{#!$perl} || $shebang =~ s{^#![/\w\.]*\s*perl\s+(-.*)$}{#!$perl $1};return if$original_shebang eq $shebang;my$content;{local $/;$content=readline$input}close$input;open(my$output,'>',$file)or do {WARN("Fail to open $file for writing");return};print {$output}$shebang ."\n";print {$output}$content;close$output;return 1}sub install_to_bin ( $self, $file, $basename = undef, $perl = $^X ) {FATAL("File is not defined")unless defined$file && length$file;FATAL("Cannot find file $file")unless -f $file;my$location=$self->bin;$self->create_if_missing($location);$basename //= File::Basename::basename($file);my$to_file=$self->bin .'/' .$basename;my$perms=0755;my$umask=umask($perms ^ 07777);DEBUG("cp $file $to_file");File::Copy::copy($file,$to_file);umask($umask);if (!-f $to_file || -s _!=-s $file){FATAL("Failed to copy file to $to_file")}$self->adjust_perl_shebang($to_file,$perl)and DEBUG("perl shebang adjusted for '$file' to use $perl");App::cplay::IPC::run3(['chmod','+x',$to_file ])unless -x $to_file;return$to_file}1;
APP_CPLAY_INSTALLDIRS

    $fatpacked{"App/cplay/Installer.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INSTALLER';
  package App::cplay::Installer;use App::cplay::std;use App::cplay;use App::cplay::Logger;use App::cplay::Module ();use App::cplay::Signature qw{check_signature};use App::cplay::Installer::Unpacker ();use App::cplay::IPC ();use App::cplay::BUILD ();use App::cplay::Installer::Command ();use Config;use File::Copy ();use File::Path ();use File::Find ();use File::Basename ();use File::pushd;use App::cplay::InstallDirs ();App::cplay::Logger->import(qw{fetch configure install resolve});use Simple::Accessor qw{cli unpacker BUILD depth local_lib_bin local_lib_lib installdirs};use constant EXTUTILS_MAKEMAKER_MIN_VERSION=>'6.64';sub build ( $self, %opts ) {$self->{_tracked_modules}={};$self->{_tracked_repositories}={};$self->{depth}=0;$self->{BUILD}={};return$self}sub _build_installdirs($self) {App::cplay::InstallDirs->new(type=>$self->cli->installdirs)}sub _build_unpacker($self) {App::cplay::Installer::Unpacker->new(tmproot=>$self->cli->build_dir)}sub check_makemaker($self) {my$module='ExtUtils::MakeMaker';my$version=EXTUTILS_MAKEMAKER_MIN_VERSION;return 1 if App::cplay::Module::has_module_version($module,$version);WARN("Trying to update ExtUtils::MakeMaker");my$ok=$self->install_single_module_or_repository($module);if (!$ok){ERROR("Please update ExtUtils::MakeMaker to $version or later");return}return$ok}sub has_module_version ( $self, $module, $version ) {if ($self->depth==1 && $self->cli->reinstall){DEBUG("(re)installing module $module");return}if ($self->cli->local_lib){return 1 if App::cplay::Module::has_module_version($module,$version,$self->cli->local_lib);if ($self->depth > 1){return 1 if App::cplay::Module::has_module_version($module,$version)}}else {return App::cplay::Module::has_module_version($module,$version)}return}sub install_from_file ( $self, $file = 'BUILD.json' ) {return unless my$BUILD=App::cplay::BUILD::create_from_file($file);$self->depth(1);my$ok=$self->install_from_BUILD($BUILD);$self->depth(0);return$ok}sub install_single_module ( $self, $module, $need_version = undef ) {return$self->install_single_module_or_repository($module,0,$need_version)}sub install_single_module_or_repository ( $self, $module_or_repository, $can_be_repo = 1, $need_version = undef ) {$self->depth($self->depth + 1);my$ok;if (defined$need_version){$ok=$self->has_module_version($module_or_repository,$need_version);DEBUG("Module $module_or_repository v$need_version is missing")unless$ok;OK("$module_or_repository is already installed.")if$ok && ($self->depth==1 || $self->cli->verbose)}if (!$ok){$ok=$self->_install_single_module_or_repository($module_or_repository,$can_be_repo);my$msg=$ok ? "install of $module_or_repository succeeded" : "install of $module_or_repository failed";DEBUG($msg);if ($ok &&!$can_be_repo && defined$need_version){$ok=$self->has_module_version($module_or_repository,$need_version);DEBUG("Module $module_or_repository v$need_version is missing")unless$ok}}$self->depth($self->depth - 1);return$ok}sub _install_single_module_or_repository ( $self, $module_or_repository, $can_be_repo = 1 ) {return 1 if$self->tracking_module($module_or_repository);my$cli=$self->cli or die;my$name_as_column_char=index($module_or_repository,':')==-1 ? 0 : 1;my$custom_requested_version;if ($module_or_repository =~ s{\@(.+)$}{}){$custom_requested_version=$1;if ($name_as_column_char){$module_or_repository =~ s{::}{-}g;FAIL("Cannot request a specific version for a module: try $module_or_repository\@$custom_requested_version");return}}my$module_info;my$repository_info;if (!defined$custom_requested_version){$module_info=$cli->modules_idx->search($module_or_repository,$custom_requested_version)}if (!$module_info &&!$name_as_column_char && $can_be_repo){$repository_info=$cli->repositories_idx->search($module_or_repository,$custom_requested_version)}if (!$module_info &&!$repository_info && defined$custom_requested_version){my$raw=$cli->explicit_versions_idx->search($module_or_repository,$custom_requested_version,0,$can_be_repo);if (!defined$raw){FAIL("Cannot find distribution $module_or_repository\@$custom_requested_version");return}$module_info={module=>$raw->{module},version=>$raw->{version}};$repository_info={repository=>$raw->{repository},version=>$raw->{repository_version},sha=>$raw->{sha},signature=>$raw->{signature},}}if (!$module_info &&!$repository_info){FAIL("Cannot find module or distribution '$module_or_repository'");return}if ($module_info){if ($self->has_module_version($module_info->{module},$module_info->{version})){my ($m,$v)=($module_info->{module},$module_info->{version});OK("$m is up to date. ($v)");return 1}$repository_info //= $cli->repositories_idx->search($module_info->{repository},$module_info->{repository_version})}if (!$repository_info){FAIL("Cannot find repository for " .$module_info->{repository});return}return$self->install_repository($repository_info)}sub install_repository ( $self, $repository_info ) {die unless ref$repository_info;my$name=$repository_info->{repository};return 1 if$self->tracking_repository($name);INFO("Installing Distribution $name");return unless$self->setup_tarball($repository_info);my$BUILD=$self->BUILD->{$name}or FATAL("Cannot find a BUILD entry for $name");my$version=$BUILD->version;if (my$primary=$BUILD->primary){my$module_v=$BUILD->provides->{$primary}->{version};if ($self->has_module_version($primary,$module_v)){OK("$name-$version is up to date.");return 1}}return$self->install_from_BUILD($BUILD,$name)}sub install_from_BUILD ( $self, $BUILD, $name = undef ) {if (!defined$name){$name=$BUILD->name;$self->BUILD->{$name}=$BUILD}my$version=$BUILD->version;return unless$self->resolve_dependencies($name);my$indir=pushd($BUILD->_rootdir);$self->_setup_local_lib_env();my$builder_type=$BUILD->builder;if ($builder_type eq 'play'){return unless$self->_builder_play($name)}elsif ($builder_type eq 'makefile.pl'){return unless$self->_builder_Makefile_PL($name)}elsif ($builder_type eq 'build.pl'){return unless$self->_builder_Build($name)}else {FATAL("Unknown builder type '$builder_type' for distribution '$name'")}$self->advertise_installed_modules($BUILD);OK("Installed distribution $name-$version");return 1}sub advertise_installed_modules ( $self, $BUILD ) {return unless ref$BUILD && ref$BUILD->provides;for my$module (sort keys %{$BUILD->provides}){my$v=$BUILD->provides->{$module}->{version}// 0;DEBUG("advertise_installed_modules: $module => $v");App::cplay::Module::module_updated($module,$v,$self->cli->local_lib)}return}sub _setup_local_lib_env ( $self, $force = 0 ) {state$done;return if$done &&!$force;$done=1;return unless my$local_lib=$self->cli->local_lib;INFO("Using local-lib: $local_lib");require Cwd;require local::lib;my$ll=local::lib->new(quiet=>1)->activate($local_lib);$ll->setup_local_lib;$ll->setup_env_hash;$self->local_lib_bin($ll->bins->[0]);$self->local_lib_lib($ll->libs->[0]);$ENV{PERL_MM_OPT}.= " INSTALLMAN1DIR=none INSTALLMAN3DIR=none";$ENV{PERL_MM_USE_DEFAULT}=1;return}sub _builder_play ( $self, $name ) {my$BUILD=$self->BUILD->{$name}or die;my@cmds;if ($self->cli->run_tests){my@tests=('t/*.t');if (defined$BUILD->tests && ref$BUILD->tests eq 'ARRAY' && scalar @{$BUILD->tests}){@tests=@{$BUILD->tests}}{File::Path::make_path('blib/lib');File::Path::make_path('blib/arch')}push@cmds,App::cplay::Installer::Command->new(type=>'test',txt=>"tests for $name",cmd=>[$^X,"-MExtUtils::Command::MM","-MTest::Harness","-e","undef *Test::Harness::Switches; test_harness(0,lib)",@tests ],env=>{PERL_DL_NONLAZY=>1,AUTHOR_TESTING=>0,RELEASE_TESTING=>0,},timeout=>$self->cli->test_timeout,)}for my$cmd (@cmds){return unless$cmd->run()}my$ok;my$install=sub {$ok=$self->_builder_play_install_files($BUILD)// 0;$ok &= $self->_builder_play_install_bin($BUILD)// 0;return};App::cplay::Timeout->new(message=>q[Reach timeout while installing files],timeout=>$self->cli->install_timeout,)->run($install);return unless$ok;return 1}sub _builder_play_install_bin ( $self, $BUILD ) {die "invalid BUILD" unless ref$BUILD eq 'App::cplay::BUILD';my$scripts=$BUILD->scripts;return 1 unless ref$scripts && scalar @$scripts;if (my$local_lib_bin=$self->local_lib_bin){INFO("installing bin to local_lib $local_lib_bin");$self->installdirs->bin($local_lib_bin)}for my$script (@$scripts){DEBUG("installing $script");$self->installdirs->install_to_bin($script)}return 1}sub _builder_play_install_files ( $self, $BUILD ) {my$inst_lib=$self->installdirs->lib;unless (defined$inst_lib && length$inst_lib){FATAL("install lib is not defined for " .$self->cli->installdirs ."\n")}if (!-d $inst_lib){DEBUG("Creating missing directory: $inst_lib");File::Path::make_path($inst_lib,{chmod=>0755,verbose=>0 })or FATAL("Fail to create $inst_lib")}FATAL("inst_lib is missing: $inst_lib")unless -d $inst_lib;if (my$local_lib_lib=$self->local_lib_lib){INFO("installing to local_lib $local_lib_lib");$inst_lib=$local_lib_lib}my$has_errors=0;my$wanted=sub {return unless -f $File::Find::name;my ($base_dir)=$File::Find::dir =~ m{^lib/(.*)};my$to_dir=$inst_lib .'/' .$base_dir;my$to_file=$to_dir .'/' .File::Basename::basename($_);if (!-d $to_dir){DEBUG("create directory $to_dir");my$ok=File::Path::make_path($to_dir,{chmod=>0755,verbose=>0 });if (!$ok){ERROR("Failed to create directory $to_dir");++$has_errors;return}}DEBUG("cp $File::Find::name $to_file");File::Copy::copy($File::Find::name,$to_file);if (!-f $to_file || -s _!=-s $File::Find::name){ERROR("Failed to copy file to $to_file");++$has_errors;return}return};my$umask=umask(0333);File::Find::find({wanted=>$wanted,no_chdir=>1 },'lib');umask($umask);return if$has_errors;install("succeeds for " .$BUILD->name);return 1}sub _builder_Makefile_PL ( $self, $name ) {my$make=App::cplay::Helpers::make_binary();my@cmds;my$use_dot=-d 'inc';my@test_cmd=($^X,$use_dot ? ('-I','.'): (),"Makefile.PL");push@cmds,App::cplay::Installer::Command->new(type=>'configure',txt=>"perl " .join(' ',@test_cmd[1 .. $#test_cmd ]),cmd=>[@test_cmd],timeout=>$self->cli->configure_timeout,);push@cmds,App::cplay::Installer::Command->new(type=>'build',txt=>"make",cmd=>$make,timeout=>$self->cli->build_timeout,);if ($self->cli->run_tests){push@cmds,App::cplay::Installer::Command->new(type=>'test',txt=>"make test",cmd=>[$make,"test" ],timeout=>$self->cli->test_timeout,)}push@cmds,App::cplay::Installer::Command->new(type=>'install',txt=>"make install",cmd=>[$make,"install" ],timeout=>$self->cli->install_timeout,);for my$cmd (@cmds){return unless$cmd->run()}return 1}sub _builder_Build ( $self, $name ) {my@cmds;push@cmds,App::cplay::Installer::Command->new(type=>'configure',txt=>"perl Build.PL",cmd=>[$^X,"Build.PL" ],timeout=>$self->cli->configure_timeout,);push@cmds,App::cplay::Installer::Command->new(type=>'build',cmd=>"./Build",timeout=>$self->cli->configure_timeout,);if ($self->cli->run_tests){push@cmds,App::cplay::Installer::Command->new(type=>'test',cmd=>["./Build","test" ],timeout=>$self->cli->test_timeout,)}push@cmds,App::cplay::Installer::Command->new(type=>'install',cmd=>["./Build","install" ],timeout=>$self->cli->install_timeout,);for my$cmd (@cmds){return unless$cmd->run()}return 1}sub resolve_dependencies ( $self, $name ) {my$BUILD=$self->BUILD->{$name}or die;my@order=qw{requires_build requires_runtime};for my$type (@order){my$requires_list=$BUILD->{$type}// {};next unless scalar keys %$requires_list;resolve("$type for $name");for my$module (sort keys %$requires_list){my$version=$requires_list->{$module};resolve("\t$name $type $module v$version");return unless$self->install_single_module($module,$version)}}return 1}sub setup_tarball ( $self, $repository_info ) {my$name=$repository_info->{repository};my$tarball=$self->download_repository($repository_info);return unless defined$tarball;my$relative_path=$self->unpacker->unpack($tarball);my$full_path=$self->cli->build_dir .'/' .$relative_path;if (!defined$relative_path ||!-d $full_path){FAIL("fail to extract tarball $tarball");return}my$dir=pushd($full_path);return unless$self->load_BUILD_json;return 1}sub load_BUILD_json($self) {return unless my$BUILD=App::cplay::BUILD::create_from_file('BUILD.json');$self->BUILD->{$BUILD->name }=$BUILD;return$BUILD}sub download_repository ( $self, $repository_info ) {my$cli=$self->cli or die;my$url=$cli->repositories_idx->get_tarball_url($repository_info)or die;fetch($url);my$name=$repository_info->{repository};my$sha=$repository_info->{sha};my$tarball="${name}.tar.gz";my$path=$cli->build_dir ."/$tarball";$cli->http->mirror($url,$path);my$signature=$repository_info->{signature};if ($self->cli->check_signature && defined$signature){if (!check_signature($path,$signature)){ERROR("Signature mismatch for $tarball expect: $signature");return}DEBUG("signature OK for $tarball = $signature")}return$path}sub tracking_module ( $self, $module ) {die unless defined$module;$module =~ s{\@.+$}{};return 1 if$self->{_tracked_modules}->{$module};$self->{_tracked_modules}->{$module}=1;return}sub tracking_repository ( $self, $repository ) {die unless defined$repository;$repository =~ s{\@.+$}{};return 1 if$self->{_tracked_repositories}->{$repository};$self->{_tracked_repositories}->{$repository}=1;return}1;
APP_CPLAY_INSTALLER

    $fatpacked{"App/cplay/Installer/Command.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INSTALLER_COMMAND';
  package App::cplay::Installer::Command;use App::cplay::std;use App::cplay::Logger;use App::cplay::Timeout ();use Simple::Accessor qw{type txt cmd timeout env};use App::cplay::IPC ();sub _build_type {'install'}sub _build_cmd {FATAL("cmd not defined for Command")}sub _build_timeout {0}sub _build_env {{}}sub _build_txt($self) {return$self->cmd unless ref$self->cmd;return join(' ',@{$self->cmd})}sub run($self) {my$type=$self->type;my$log_type=App::cplay::Logger->can($type)or FATAL("Unknown helper to log $type");$log_type->("running " .$self->txt);my ($status,$out,$err);my$todo=sub {($status,$out,$err)=App::cplay::IPC::run3($self->cmd)};local%ENV=(%ENV,%{$self->env});if ($self->timeout){App::cplay::Timeout->new(message=>q[Reach timeout while running ] .$self->txt,timeout=>$self->timeout,)->run($todo)}else {$todo->()}if ($status!=0){ERROR("Fail to run " .$self->txt);return}return 1}1;
APP_CPLAY_INSTALLER_COMMAND

    $fatpacked{"App/cplay/Installer/Share.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INSTALLER_SHARE';
  package App::cplay::Installer::Share;use App::cplay::std;use App::cplay::Logger;1;
APP_CPLAY_INSTALLER_SHARE

    $fatpacked{"App/cplay/Installer/Unpacker.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_INSTALLER_UNPACKER';
  package App::cplay::Installer::Unpacker;use App::cplay::std;use App::cplay::IPC ();use File::Basename ();use File::Temp ();use File::Which ();use File::pushd;sub new ( $class, %argv ) {my$self=bless \%argv,$class;$self->_init_untar;return$self}sub unpack ( $self, $file ) {my$method=$self->{method}{untar};my$dir;$dir=pushd($self->{tmproot})if$self->{tmproot};return$self->can($method)->($self,$file)}sub _init_untar($self) {my$tar=$self->{tar}=File::Which::which('gtar')|| File::Which::which("tar");if ($tar){my ($exit,$out,$err)=App::cplay::IPC::run3 [$tar,'--version' ];$self->{tar_kind}=$out =~ /bsdtar/ ? "bsd" : "gnu";$self->{tar_bad}=1 if$out =~ /GNU.*1\.13/i || $^O eq 'MSWin32' || $^O eq 'solaris' || $^O eq 'hpux'}if ($tar and!$self->{tar_bad}){$self->{method}{untar}=*_untar;return if!$self->{_init_all}}my$gzip=$self->{gzip}=File::Which::which("gzip");my$bzip2=$self->{bzip2}=File::Which::which("bzip2");if ($tar && $gzip && $bzip2){$self->{method}{untar}=*_untar_bad;return if!$self->{_init_all}}if (eval {require Archive::Tar}){$self->{"Archive::Tar"}=Archive::Tar->VERSION;$self->{method}{untar}=*_untar_module;return if!$self->{_init_all}}return if$self->{_init_all};$self->{method}{untar}=sub {die "There is no backend for untar"}}sub _untar ( $self, $file ) {my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? 'j' : 'z';($exit,$out,$err)=App::cplay::IPC::run3 [$self->{tar},"${ar}tf",$file ];last if$exit!=0;my$root=$self->_find_tarroot(split /\r?\n/,$out);($exit,$out,$err)=App::cplay::IPC::run3 [$self->{tar},"${ar}xf",$file,"-o" ];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_bad ( $self, $file ) {my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? $self->{bzip2}: $self->{gzip};my$temp=File::Temp->new(SUFFIX=>'.tar',EXLOCK=>0);($exit,$out,$err)=App::cplay::IPC::run3 [$ar,"-dc",$file ],$temp->filename;last if$exit!=0;my@opt=$^O eq 'MSWin32' && $self->{tar_kind}ne "bsd" ? ('--force-local'): ();($exit,$out,$err)=App::cplay::IPC::run3 [$self->{tar},@opt,"-tf",$temp->filename ];last if$exit!=0 ||!$out;my$root=$self->_find_tarroot(split /\r?\n/,$out);($exit,$out,$err)=App::cplay::IPC::run3 [$self->{tar},@opt,"-xf",$temp->filename,"-o" ];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_module ( $self, $file ) {my$wantarray=wantarray;no warnings 'once';local$Archive::Tar::WARN=0;my$t=Archive::Tar->new;{my$ok=$t->read($file);last if!$ok;my$root=$self->_find_tarroot($t->list_files);my@file=$t->extract;return$root if@file and -d $root}return if!$wantarray;return (undef,$t->error)}sub _find_tarroot ( $self, $root, @others ) {FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length$root){$root=shift@others;redo FILE if$root}}return$root}1;
APP_CPLAY_INSTALLER_UNPACKER

    $fatpacked{"App/cplay/Logger.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_LOGGER';
  package App::cplay::Logger;use App::cplay::std;use List::Util 'max';use Exporter 'import';$|=1;our@EXPORT=qw{OK DONE FAIL ERROR WARN INFO DEBUG FATAL};our@EXPORT_OK=(@EXPORT,qw(fetch resolve install configure build test RUN STDERROR));our$COLOR;our$VERBOSE;our$DEBUG;our$SHOW_PROGRESS;BEGIN {$COLOR=1 if -t STDIN}use constant COLOR_RED=>31;use constant COLOR_GREEN=>32;use constant COLOR_YELLOW=>33;use constant COLOR_BLUE=>34;use constant COLOR_PURPLE=>35;use constant COLOR_CYAN=>36;use constant COLOR_WHITE=>7;my%color=(resolve=>COLOR_YELLOW,fetch=>COLOR_BLUE,configure=>COLOR_PURPLE,build=>COLOR_PURPLE,test=>COLOR_PURPLE,install=>COLOR_CYAN,FAIL=>COLOR_RED,ERROR=>COLOR_RED,STDERROR=>COLOR_RED,FATAL=>COLOR_RED,DONE=>COLOR_GREEN,OK=>COLOR_GREEN,WARN=>COLOR_YELLOW,INFO=>COLOR_GREEN,DEBUG=>COLOR_WHITE,RUN=>COLOR_WHITE,);sub new ( $class, @args ) {return bless {@args},$class}sub setup_for_script {$VERBOSE=1;$SHOW_PROGRESS=0;return}sub log ( $self_or_class, %options ) {my$type=$options{type}|| "";my$message=$options{message};chomp$message;my$optional=$options{optional}? " ($options{optional})" : "";my$result=$options{result};my$is_color=ref$self_or_class ? $self_or_class->{color}: $COLOR;my$verbose=ref$self_or_class ? $self_or_class->{verbose}: $VERBOSE;my$show_progress=ref$self_or_class ? $self_or_class->{show_progress}: $SHOW_PROGRESS;if (!$result && $DEBUG){my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);$year += 1900;$mon++;$result=sprintf('[%04d-%02d-%02d %02d:%02d:%02d]',$year,$mon,$mday,$hour,$min,$sec,)}$result //= '';if ($is_color){$type="\e[$color{$type}m$type\e[m" if$type && $color{$type};$result="\e[$color{$result}m$result\e[m" if$result && $color{$result};$optional="\e[1;37m$optional\e[m" if$optional}my$eol=$show_progress &&!$options{no_progress}? "" : "\n";my$r=$show_progress ? "\r\033[K" : "";if ($verbose){$type=$is_color && $type ? sprintf("%-17s",$type): sprintf("%-9s",$type || "");print STDERR$r .sprintf "%s %s %s%s$eol",$result,$type,$message,$optional}else {print STDERR$r .join(" ",map {defined $_ ? $_ : ()}$result,$type,$message .$optional).$eol}return}sub OK ( $msg, @args ) {return __PACKAGE__->log(type=>'OK',message=>$msg,no_progress=>1,@args)}sub DONE ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'DONE',message=>$msg,no_progress=>1,@args)}sub DEBUG ( $msg, @args ) {return unless$DEBUG;return __PACKAGE__->log(type=>'DEBUG',message=>$msg,@args)}sub RUN ( $msg, @args ) {return unless$DEBUG;return __PACKAGE__->log(type=>'RUN',message=>$msg,@args)}sub FAIL ( $msg, @args ) {return __PACKAGE__->log(type=>'FAIL',message=>$msg,no_progress=>1,@args)}sub ERROR ( $msg, @args ) {return __PACKAGE__->log(type=>'ERROR',message=>$msg,no_progress=>1,@args)}sub STDERROR ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'STDERROR',message=>$msg,no_progress=>1,@args)}sub FATAL ( $msg, @args ) {__PACKAGE__->log(type=>'FATAL',message=>$msg,no_progress=>1,@args);die$msg}sub WARN ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'WARN',message=>$msg,no_progress=>1,@args)}sub INFO ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'INFO',message=>$msg,@args)}sub fetch ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'fetch',message=>$msg,@args)}sub resolve ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'resolve',message=>$msg,@args)}sub configure ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'configure',message=>$msg,@args)}sub install ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'install',message=>$msg,@args)}sub build ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'build',message=>$msg,@args)}sub test ( $msg, @args ) {return unless$VERBOSE;return __PACKAGE__->log(type=>'test',message=>$msg,@args)}1;
APP_CPLAY_LOGGER

    $fatpacked{"App/cplay/Module.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_MODULE';
  package App::cplay::Module;use App::cplay::std;use App::cplay::Logger;use App::cplay::IPC;use Exporter 'import';our@EXPORT=qw(has_module_version);our@EXPORT_OK=(@EXPORT,qw{get_module_version module_updated});my%CACHE;my%GOT;sub has_module_version ( $module, $version, $local_lib = undef ) {my$IN=_in($local_lib);$version //= 0;if (defined$CACHE{$module}&& defined$CACHE{$module}->{$IN}&& defined$CACHE{$module}->{$IN}->{$version}){return$CACHE{$module}->{$IN}->{$version}}$CACHE{$module}//= {};$CACHE{$module}->{$IN}//= {};my$has_module=0;my$got_version=get_module_version($module,$local_lib);$version =~ s{^\s*>=\s*}{};if (lc$module eq 'perl' && $version =~ m{^v?(\d+)\.(\d+)\.(\d+)$}ia){$version=sprintf("%d.%03d%03d",$1,$2,$3)}if (defined$got_version){if ($got_version eq $version){$has_module=1}else {my$version_check=eval qq{ $version > $got_version ? 0 : 1 };if (!defined$version_check){WARN("module $module version is not numeric: $got_version")}elsif ($version_check){$has_module=1}}}DEBUG("has_module $module >= $version ? $has_module [got " .($got_version // '').']');$CACHE{$module}->{$IN}->{$version}=$has_module;return$has_module}sub get_module_version ( $module, $local_lib = undef ) {my$IN=_in($local_lib);return$GOT{$module}->{$IN}if defined$GOT{$module}&& defined$GOT{$module}->{$IN};return "$]" if lc$module eq 'perl';my$version;if (!defined$local_lib){my$oneliner=qq|eval { require $module; 1 } or die; print eval { \$${module}::VERSION } // 0|;my ($status,$out,$err)=App::cplay::IPC::run3([$^X,'-e',$oneliner ]);if ($status==0){$version=$out;chomp$version if$version}}else {local$ENV{PERL5LIB};my$pp=$module;$pp =~ s{::}{/}g;$pp .= '.pm';my$oneliner=<<"EOS";my ($status,$out,$err)=App::cplay::IPC::run3([$^X,"-mlocal::lib=--no-create,$local_lib",'-e',$oneliner ]);if ($status==0){$version=$out;chomp$version if$version}}$GOT{$module}//= {};$GOT{$module}->{$IN}=$version;DEBUG("get_module_version $module = " .($version // ''));return$version}sub module_updated ( $module, $version, $local_lib = undef ) {die("Missing module name")unless defined$module;my$IN=_in($local_lib);delete$CACHE{$module};$GOT{$module}//= {};$GOT{$module}->{$IN}=$version;return}sub _in ( $local_lib = undef ) {return$local_lib // 'default'}sub clear_module( $module ) {delete$CACHE{$module};delete$GOT{$module};return}sub clear_cache {%CACHE=();%GOT=();return}1;
  eval { require $module; 1 } or die; 
  die unless \$INC{"$pp"} =~ m{^\Q$local_lib\E}; 
  print eval { \$${module}::VERSION } // 0;
  EOS
APP_CPLAY_MODULE

    $fatpacked{"App/cplay/Roles/JSON.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_ROLES_JSON';
  package App::cplay::Roles::JSON;use App::cplay::std;use JSON::PP ();use Simple::Accessor qw{json};sub _build_json($self) {return JSON::PP->new->utf8->relaxed->allow_nonref}1;
APP_CPLAY_ROLES_JSON

    $fatpacked{"App/cplay/Signature.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_SIGNATURE';
  package App::cplay::Signature;use App::cplay::std;use App::cplay::Logger;use Digest::Perl::MD5;use Exporter 'import';our@EXPORT=qw{check_signature};our@EXPORT_OK=@EXPORT;sub check_signature ( $file, $expect ) {return unless -e $file && defined$expect;open(my$fh,'<:utf8',$file)or die "Cannot open file $file: $!";my$ctx=_get_ctx();$ctx->addfile($fh);return$ctx->hexdigest eq $expect}sub _get_ctx {state$warn_once;if (eval q{require Digest::MD5; 1 }){return Digest::MD5->new}if (!$warn_once){$warn_once=1;WARN("Consider installing Digest::MD5, using Digest::Perl::MD5")}return Digest::Perl::MD5->new}1;
APP_CPLAY_SIGNATURE

    $fatpacked{"App/cplay/Starter.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_STARTER';
  package App::cplay::Starter;use App::cplay::std;use App::cplay::Logger;use App::cplay::Helpers qw{write_file};use Simple::Accessor qw{distribution module primary_dir primary_file BUILD root_directory};use App::cplay::BUILD ();use File::Copy ();use File::Path qw(make_path);use File::Find ();use File::Basename ();use File::pushd;sub build ( $self, %opts ) {die "Missing module_or_distribution" unless my$module_or_distribution=delete$opts{module_or_distribution};die "Too many args" if scalar keys%opts;delete$self->{module_or_distribution};my$distribution;($distribution=$module_or_distribution)=~ s{::}{-}g;$distribution =~ s{-+}{-}g;$self->{distribution}=$distribution;return$self}sub _build_module($self) {my$module=$self->distribution;$module =~ s{-}{::}g;return$module}sub _build_root_directory($self) {my$distribution=$self->distribution;if ($distribution !~ m{^[a-zA-Z0-9-]+$}){ERROR("Invalid distribution name: $distribution");return}return$distribution}sub _build_primary_dir($self) {my$distribution=$self->distribution;if ($distribution =~ m{^(.+)-[^-]+$}){my$inlib=$1;$inlib =~ s{-}{/}g;FATAL("directory should not start by /")if$inlib =~ m{^/};return "lib/$inlib"}return "lib"}sub _build_primary_file($self) {my$distribution=$self->distribution;my@subs=split('-',$distribution);return$self->primary_dir .'/' .$subs[-1].'.pm'}sub create_root_directory($self) {return unless my$dir=$self->root_directory;return!!make_path($dir,{verbose=>0,mode=>0711 })}sub create_directories($self) {my@dirs=qw{t};push@dirs,$self->primary_dir;for my$d (@dirs){next if make_path($d,{verbose=>0,mode=>0711 });my$distribution=$self->distribution;ERROR("Fail to create sub directory '$d' for $distribution");return}return 1}sub add_primary_pm($self ) {my$file=$self->primary_file;my$module=$self->module;my$content=<<'EOS';$content =~ s{~module~}{$module}g;return eval {write_file($file,$content);1}}sub add_test($self) {my$module=$self->module;my$file=q[t/00-load.t];my$content=<<'EOS';$content =~ s{~module~}{$module}g;return eval {write_file($file,$content);1}}sub add_BUILD($self) {my$build=App::cplay::BUILD->new(abstract=>"Abstract for " .$self->distribution,name=>$self->distribution,primary=>$self->module,);push @{$build->maintainers},'Your Name <your@email.tld>';$build->provides->{$self->module }={file=>$self->primary_file,version=>$build->version,};return$build->save_to_file}sub git_init($self) {}sub create($self) {INFO("creating repository " .$self->distribution);return unless$self->create_root_directory();DEBUG("root = " .$self->root_directory);my$in_dir=pushd($self->root_directory);DEBUG("create sub directories");return unless$self->create_directories();DEBUG("add main .pm file");return unless$self->add_primary_pm();DEBUG("add unit test");return unless$self->add_test();DEBUG("add BUILD.json");return unless$self->add_BUILD();DEBUG("init git");$self->git_init();return 1}1;
  #!perl
  
  package ~module~;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.001';
  
  1;
  EOS
  #!perl
  
  use Test::More;
  
  use_ok "~module~";
  
  ok defined $~module~::VERSION, "VERSION set";
  
  done_testing;
  EOS
APP_CPLAY_STARTER

    $fatpacked{"App/cplay/Timeout.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_TIMEOUT';
  package App::cplay::Timeout;use App::cplay::std;use App::cplay::Logger;use Simple::Accessor qw{timeout message prevsig};sub run ( $self, $code ) {local$SIG{'ALRM'}=sub {FATAL$self->message;die};alarm($self->timeout);my@out=$code->();alarm(0);return@out}1;
APP_CPLAY_TIMEOUT

    $fatpacked{"App/cplay/cli.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CLI';
  package App::cplay::cli;use App::cplay::std;use App::cplay ();use App::cplay::Logger;use App::cplay::Http;use App::cplay::cmd::cpanfile ();use App::cplay::cmd::fromtarball ();use App::cplay::cmd::getrepo ();use App::cplay::cmd::help ();use App::cplay::cmd::install ();use App::cplay::cmd::look ();use App::cplay::cmd::selfinstall ();use App::cplay::cmd::selfupdate ();use App::cplay::cmd::start ();use App::cplay::cmd::version ();use App::cplay::Index::Repositories;use App::cplay::Index::Modules;use App::cplay::Index::ExplicitVersions;use Cwd ();use Simple::Accessor qw{name http cwd homedir build_dir cache_dir local_lib snapshot retry configure_timeout build_timeout test_timeout install_timeout check_signature refresh run_tests installdirs features reinstall debug verbose repositories_idx modules_idx explicit_versions_idx};use File::Path qw(mkpath rmtree);use Getopt::Long qw(:config no_auto_abbrev no_ignore_case bundling);use Pod::Text ();sub build ( $self, %options ) {for my$k (sort keys%options){$self->{$k}=$options{$k}}$self->cwd;my$defaults={check_signature=>1,with_requires=>1,with_recommends=>0,with_suggests=>0,with_configure=>0,with_build=>1,with_test=>1,with_runtime=>1,with_develop=>0,};for my$k (sort %$defaults){$self->{$k}//= $defaults->{$k}}$self->{features}=[];return$self}sub _build_cwd {return Cwd::cwd()}sub _build_homedir {$ENV{HOME}or die q[HOME environmenet variable not set]}sub _build_cache_dir($self) {my$path=$self->homedir .'/.cplay';return$path if -d $path;mkpath($path)or FATAL("Fail to create ~/.cplay cache directory directory at: $path");return$path}sub _build_build_dir($self) {my$path=$self->cache_dir .'/build';return$path if -d $path;mkpath($path)or die "fail to create build directory at: $path";return$path}sub DESTROY($self) {if (ref$self && $self->{builddir}&& $self->{cleanup}){my$dir=$self->{builddir};if (-d $dir &&!-l $dir){DEBUG("rmtree .build directory: $dir");File::Path::rmtree($dir)}}}sub _build_retry {1}sub _build_configure_timeout {60}sub _build_install_timeout {60}sub _build_build_timeout {3_600}sub _build_test_timeout {1_800}sub _build_http {App::cplay::Http->create}sub _build_repositories_idx($self) {App::cplay::Index::Repositories->new(cli=>$self)}sub _build_modules_idx($self) {App::cplay::Index::Modules->new(cli=>$self)}sub _build_explicit_versions_idx($self) {App::cplay::Index::ExplicitVersions->new(cli=>$self)}sub parse_options ( $self, @opts ) {local@ARGV=@opts;my (@feature);my$with_option=sub {my$n=shift;("with-$n",\$self->{"with_$n"},"without-$n",sub {$self->{"with_$n"}=0})};my@with_types=qw(requires recommends suggests);my@with_phases=qw(configure build test runtime develop);my$n_tests;GetOptions("color!"=>\($self->{color}),'cleanup!'=>\($self->{cleanup}),"cache|cache-dir=s"=>\($self->{cache_dir}),"check-signature!"=>\($self->{check_signature}),'test!'=>\($self->{run_tests}),'tests!'=>\($self->{run_tests}),'n'=>\$n_tests,"refresh"=>\($self->{refresh}),"reinstall"=>\($self->{reinstall}),"v|verbose"=>\($self->{verbose}),"d|debug"=>\($self->{debug}),"L|local-lib=s"=>\($self->{local_lib}),"installdir|installdirs=s"=>\($self->{installdirs}),"show-progress!"=>\($self->{show_progress}),"feature=s@"=>\@feature,"retry!"=>\($self->{retry}),"configure-timeout=i"=>\($self->{configure_timeout}),"build-timeout=i"=>\($self->{build_timeout}),"test-timeout=i"=>\($self->{test_timeout}),"install-timeout=i"=>\($self->{install_timeout}),"with-all"=>sub {map {$self->{"with_$_"}=1}@with_types,@with_phases},(map$with_option->($_),@with_types),(map$with_option->($_),@with_phases),)or exit 1;$self->{color}=1 if!defined$self->{color}&& -t STDOUT;$self->{show_progress}=1 if!defined$self->{show_progress}&& -t STDOUT;$self->{show_progress}=0 if$self->debug;$self->{show_progress}=0 unless -t STDIN;$self->{features}=\@feature if@feature;$self->{run_tests}=0 if$n_tests;$self->run_tests(1)unless defined$self->{run_tests};if (!$self->run_tests){$self->{'with_test'}=0}if (defined$self->{local_lib}){$self->{local_lib}=~ s{^=}{};$self->{local_lib}=Cwd::abs_path($self->local_lib)}if (defined$self->{local_lib}and defined$self->{installdirs}){FATAL("local_lib and installdir options are mutually exclusive.")}if (defined$self->{cache_dir}){$self->{cache_dir}=Cwd::abs_path($self->cache_dir);mkpath($self->cache_dir)unless -d $self->cache_dir;FATAL("Cannot find cache directory at " .$self->{cache_dir})unless -d $self->cache_dir}$self->{verbose}=1 if$self->{debug};$self->{cleanup}//= 1;$App::cplay::Logger::COLOR=1 if$self->{color};$App::cplay::Logger::VERBOSE=1 if$self->{verbose};$App::cplay::Logger::DEBUG=1 if$self->{debug};$App::cplay::Logger::SHOW_PROGRESS=1 if$self->{show_progress};if (@ARGV && $ARGV[0]eq "-"){$self->{argv}=$self->read_argv_from_stdin;$self->{cpanfile}=undef}else {$self->{argv}=\@ARGV}return$self}sub read_argv_from_stdin {my$self=shift;my@argv;while (my$line=<STDIN>){next if$line !~ /\S/;next if$line =~ /^\s*#/;$line =~ s/^\s*//;$line =~ s/\s*$//;push@argv,split /\s+/,$line}return \@argv}sub get_cmd_sub_for ( $self, $cmd ) {return unless defined$cmd;$cmd =~ s{^-+}{};$cmd =~ s{-}{}g;my$aliases={h=>'help',v=>'version',V=>'version',i=>'install',c=>'cpanfile',f=>'fromtarball',};$cmd=$aliases->{$cmd}if defined$aliases->{$cmd};return unless$cmd =~ m{^[A-Za-z0-9_]+$};return "App::cplay::cmd::$cmd"->can('run')}sub run ( $self, @argv ) {my$cmd='';my$run;if (scalar@argv){if ($run=$self->get_cmd_sub_for($argv[0])){$cmd=shift@argv}else {$run=$self->get_cmd_sub_for('install');$cmd='install'}}else {$run=$self->get_cmd_sub_for('help');$cmd='help'}die qq[Unknown subcommand '$cmd'] unless defined$run && ref$run eq 'CODE';$self->parse_options(@argv);$cmd =~ s{^-+}{} if$cmd;if ($cmd && $cmd !~ m{^(?:help|version)$}){INFO("Running action '$cmd'")}return$run->($self,@{$self->{argv}})}1;
APP_CPLAY_CLI

    $fatpacked{"App/cplay/cmd/cpanfile.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_CPANFILE';
  package App::cplay::cmd::cpanfile;use App::cplay::std;use App::cplay::Logger;use App::cplay::Installer;use App::cplay::Module qw(get_module_version);sub run ( $self, @files ) {my$installer=App::cplay::Installer->new(cli=>$self);return 1 unless$installer->check_makemaker();return 1 unless _install_and_load_cpanfile($installer);push@files,'cpanfile' unless scalar@files;my@phases=grep$self->{"with_$_"},qw(configure build test runtime develop);my@types=grep$self->{"with_$_"},qw(requires recommends suggests);my@features=@{$self->features};for my$f (@files){$f='cpanfile' if$f eq '.';INFO("parsing cpanfile $f");my$cpanfile=Module::CPANfile->load($f);my$prereqs=$cpanfile->prereqs_with(@features);next unless$prereqs;my$reqs=$prereqs->merged_requirements(\@phases,\@types)->as_string_hash;next unless$reqs;if (my$need_perl_version=$reqs->{'perl'}){if ("$]" < $need_perl_version){ERROR("Needs Perl >= $need_perl_version, this is Perl $].");return 1}delete$reqs->{'perl'}}for my$module (sort keys %$reqs){my$version_range=$reqs->{$module};DEBUG("installing last version of $module");return 1 unless$installer->install_single_module($module,$version_range)}}DONE("install cpanfile succeeds");return 0}sub _install_and_load_cpanfile($installer) {return 1 if eval {require Module::CPANfile;1};WARN("Module::CPANfile is not available trying to install it");if (!$installer->install_single_module('Module::CPANfile')){ERROR("Fail to install Module::CPANfile");return}return eval {require Module::CPANfile;1}}1;
APP_CPLAY_CMD_CPANFILE

    $fatpacked{"App/cplay/cmd/fromtarball.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_FROMTARBALL';
  package App::cplay::cmd::fromtarball;use App::cplay::std;use App::cplay::Logger;use App::cplay::Installer;use App::cplay::BUILD;use File::Path ();use Cwd;sub run ( $cli, @args ) {do {ERROR("Need a single tarball");return 1}unless scalar@args==1;my$installer=App::cplay::Installer->new(cli=>$cli);return 1 unless$installer->check_makemaker();my$tarball=$args[0];INFO("Installing module from tarball $tarball");return 1 unless my$path=setup_tarball($installer,$tarball);DEBUG("tarball is extracted at $path");return 1 unless$installer->install_from_file("$path/BUILD.json");File::Path::rmtree($path);DONE("install fromtarball succeeds");return 0}sub setup_tarball ( $installer, $tarball_or_url ) {my ($tarball,$has_downloaded)=download_if_needed($installer,$tarball_or_url);return unless defined$tarball && -f $tarball;DEBUG("Using tarball from $tarball");my$relative_path=$installer->unpacker->unpack($tarball);my$full_path=$installer->cli->build_dir .'/' .$relative_path;unlink($tarball)if$has_downloaded;if (!defined$relative_path ||!-d $full_path){FAIL("fail to extract tarball $tarball");return}return$full_path}sub download_if_needed ( $installer, $tarball_or_url ) {if ($tarball_or_url !~ m{^https?://}i){return Cwd::abs_path($tarball_or_url)if -e $tarball_or_url;ERROR("Do not know how to setup tarball: $tarball_or_url");return}my$basename="fromtarball-$$.tar.gz";my$path=$installer->cli->build_dir ."/$basename";App::cplay::Logger::fetch($tarball_or_url);$installer->cli->http->mirror($tarball_or_url,$path);return ($path,1)}1;
APP_CPLAY_CMD_FROMTARBALL

    $fatpacked{"App/cplay/cmd/getrepo.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_GETREPO';
  package App::cplay::cmd::getrepo;use App::cplay::std;use App::cplay::Logger;sub run ( $cli, @argv ) {die "Need one and only one argument" unless scalar@argv==1;require Module::CoreList;my$module=$argv[0];my$module_info=$cli->modules_idx->search($module);my$is_core=Module::CoreList->is_core($module);if ($module eq 'perl' || $is_core){my$first_release=Module::CoreList->first_release($module);say 'CORE',$first_release ? " v$first_release" : '';return}if (!ref$module_info &&!defined$module_info->{repository}){ERROR("Cannot find a repository for module '$module'");return 1}say$module_info->{repository};return}1;
APP_CPLAY_CMD_GETREPO

    $fatpacked{"App/cplay/cmd/help.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_HELP';
  package App::cplay::cmd::help;use App::cplay::std;use Pod::Text ();sub run ( $self, @argv ) {my$out;open my$fh,">",\$out;my$f=$INC{'App/cplay.pm'};$f=$0 unless -e $f;Pod::Text->new->parse_from_file($f,$fh);if (defined$out){$out =~ s/^[ ]{6}/    /mg;print STDERR$out}return 0}1;
APP_CPLAY_CMD_HELP

    $fatpacked{"App/cplay/cmd/install.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_INSTALL';
  package App::cplay::cmd::install;use App::cplay::std;use App::cplay::Logger;use App::cplay::Installer;sub run ( $self, @modules ) {return 1 unless scalar@modules;my$installer=App::cplay::Installer->new(cli=>$self);return 1 unless$installer->check_makemaker();for my$module (@modules){if ($module eq '.'){INFO "Installing distribution from .";if (!$installer->install_from_file()){FAIL "Fail to install distribution from .";return 1}next}INFO("Looking for module: $module");if (!$installer->install_single_module_or_repository($module)){FAIL("Fail to install $module or its dependencies.");return 1}}DONE("install cmd succeeds");return 0}1;
APP_CPLAY_CMD_INSTALL

    $fatpacked{"App/cplay/cmd/look.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_LOOK';
  package App::cplay::cmd::look;use App::cplay::std;use App::cplay::Logger;use File::Which ();use File::Path qw(mkpath rmtree);use File::pushd;sub run ( $cli, @argv ) {die "Need one and only distribution or module name" unless scalar@argv==1 && defined$argv[0];die "Cannot detect STDIN" unless -t STDIN;my$module_or_distro=$argv[0];my$module_info=$cli->modules_idx->search($module_or_distro);my$repository_info;if (defined$module_info){$repository_info=$cli->repositories_idx->search($module_info->{repository})}else {$repository_info=$cli->repositories_idx->search($module_or_distro)}if (!$repository_info){ERROR("Cannot find distribution for '$module_or_distro'");return 1}my$repository_name=$repository_info->{repository};DEBUG("Found repository '$repository_name'");my$git=File::Which::which('git');if ($git && -x $git){my$url=$cli->repositories_idx->get_git_repository_url($repository_info);my$base_dir=$cli->cache_dir .'/git-repos';my$dir=$base_dir .'/' .$repository_name;mkpath($base_dir)unless -d $base_dir;rmtree($dir)if -d $dir;my ($exit,$out,$err)=App::cplay::IPC::run3([$git,'clone',$url,$dir ]);if ($exit!=0 ||!-d $dir){ERROR("Fail to clone git repository '$url'");return 1}{my$shell=$ENV{SHELL}|| File::Which::which('bash')|| File::Which::which('sh');if (!-x $shell){ERROR("Cannot find a valid shell, set SHELL env. variable");INFO("repository was cloned to $dir");INFO("     cd $dir");return 1}my$in_dir=pushd($dir);INFO("Opening a new shell session to '$dir'");system$shell}DEBUG("Removing temporary directory: '$dir'");rmtree($dir)if -d $dir}else {WARNING("Cannot find a git binary in your PATH");return 1}return}1;
APP_CPLAY_CMD_LOOK

    $fatpacked{"App/cplay/cmd/selfinstall.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_SELFINSTALL';
  package App::cplay::cmd::selfinstall;use App::cplay::std;use App::cplay::Logger;use App::cplay::Installer;use App::cplay::Helpers qw{write_file is_fatpacked};use File::Basename ();use Cwd ();sub run ( $cli, @argv ) {if (!is_fatpacked()){FAIL("Can only install a FatPacked version of 'cplay'.");return 1}FATAL("No source code")unless length($main::SOURCE_CODE // '');App::cplay::Logger::setup_for_script();my$tmp_file=$cli->build_dir ."/cplay.tmp";write_file($tmp_file,$main::SOURCE_CODE);my$installer=App::cplay::Installer->new(cli=>$cli);my$dirs=$installer->installdirs;my$path=$dirs->install_to_bin($tmp_file,'cplay');OK "cplay is installed to $path";check_path_for($path);unlink$tmp_file;return}sub check_path_for($bin) {my$indir=File::Basename::dirname(Cwd::abs_path($bin));if (defined$ENV{PATH}){my@path=split(':',$ENV{PATH});for my$p (@path){next unless$p =~ m{^/};$p=Cwd::abs_path($p);return 1 if$p eq $indir}}WARN("$indir is not in your PATH");return}1;
APP_CPLAY_CMD_SELFINSTALL

    $fatpacked{"App/cplay/cmd/selfupdate.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_SELFUPDATE';
  package App::cplay::cmd::selfupdate;use App::cplay ();use App::cplay::std;use App::cplay::Logger;use App::cplay::Installer;use App::cplay::InstallDirs;use App::cplay::Helpers qw{write_file is_fatpacked update_shebang};use File::Basename ();use Cwd ();use File::Copy ();use constant URL=>q[http://get.cplay.us/];sub run ( $cli, @argv ) {if (!is_fatpacked()){FAIL("Can only update a FatPacked version of 'cplay'.");return 1}App::cplay::Logger::setup_for_script();my$force=grep {$_ eq 'force'}@argv;INFO("running 'selfupdate force'")if$force;my$installer=App::cplay::Installer->new(cli=>$cli);my$tmp_file=$installer->cli->build_dir ."/cplay.tmp";unlink$tmp_file if -e $tmp_file;$installer->cli->http->mirror(URL,$tmp_file);if (!-f $tmp_file || -z _){FAIL("Fail to download cplay from " .URL);return 1}my$current_version=$App::cplay::VERSION .'@' .$App::cplay::REVISION;my ($exit,$out,$err)=App::cplay::IPC::run3(["$^X",$tmp_file,q[--version] ]);my$new_version;if ($out && $out =~ m{^cplay\s+(\d+\.\d+\@\w+)\b}a){$new_version=$1}if ($exit || $err ||!defined$new_version ||!length$new_version){FAIL("Cannot get cplay version from " .URL);return 1}if (!$force && $current_version eq $new_version){OK("cplay is already up to date using version '$current_version'");INFO("you can force an update by running: cplay selfupdate force");return}DEBUG("current_version: $current_version ; target_version: $new_version");my$to_file=Cwd::abs_path($0);if (!-e $to_file){FAIL("Do not know how to update $0");return 1}update_shebang($tmp_file);DEBUG("cp $tmp_file $to_file");File::Copy::copy($tmp_file,$to_file)or do {FAIL("Cannot copy $tmp_file to $to_file");return 1};OK("cplay is updated to version '$new_version'");unlink$tmp_file;return}1;
APP_CPLAY_CMD_SELFUPDATE

    $fatpacked{"App/cplay/cmd/start.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_START';
  package App::cplay::cmd::start;use App::cplay::std;use App::cplay::Logger;use App::cplay::Starter;use Cwd;use File::pushd;sub run ( $cli, @modules ) {if (!scalar@modules){ERROR("Need one or more module / distribution name");return 1}my$root=getcwd;for my$module (@modules){my$in_dir=pushd($root);my$ok=eval {App::cplay::Starter->new(module_or_distribution=>$module)->create};if ($ok){OK("Directory for $module created.")}else {FAIL("Cannot create directory for $module.");DEBUG("Error: $@");return 1}}return 0}1;
APP_CPLAY_CMD_START

    $fatpacked{"App/cplay/cmd/version.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_CMD_VERSION';
  package App::cplay::cmd::version;use App::cplay::std;sub run ( $self, @argv ) {my$version=$App::cplay::VERSION;my$revision=$App::cplay::REVISION;say "cplay $version\@$revision ($0)";return}1;
APP_CPLAY_CMD_VERSION

    $fatpacked{"App/cplay/std.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'APP_CPLAY_STD';
  package App::cplay::std;use strict;use warnings;use utf8;sub import {warnings->import();strict->import();require feature;feature->import(':5.20');feature->import('signatures');utf8->import();warnings->unimport('experimental::signatures');return}1;
APP_CPLAY_STD

    $fatpacked{"Digest/Perl/MD5.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'DIGEST_PERL_MD5';
  package Digest::Perl::MD5;use strict;use integer;use Exporter;use vars qw($VERSION @ISA @EXPORTER @EXPORT_OK);@EXPORT_OK=qw(md5 md5_hex md5_base64);@ISA='Exporter';$VERSION='1.9';sub A() {0x67_45_23_01}sub B() {0xef_cd_ab_89}sub C() {0x98_ba_dc_fe}sub D() {0x10_32_54_76}sub MAX() {0xFFFFFFFF}sub padding {my$l=length(my$msg=shift().chr(128));$msg .= "\0" x (($l % 64 <= 56 ? 56 : 120)- $l % 64);$l=($l - 1)* 8;$msg .= pack 'VV',$l & MAX,($l >> 16 >> 16)}sub rotate_left($$) {($_[0]<< $_[1])| (($_[0]>> (32 - $_[1]))& ((1 << $_[1])- 1))}sub gen_code {my$MSK=((1 << 16)<< 16)? ' & ' .MAX : '';my%f=(FF=>"X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",GG=>"X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;",HH=>"X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;",II=>"X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",);my%s=(S11=>7,S12=>12,S13=>17,S14=>22,S21=>5,S22=>9,S23=>14,S24=>20,S31=>4,S32=>11,S33=>16,S34=>23,S41=>6,S42=>10,S43=>15,S44=>21);my$insert="\n";while (defined(my$data=<DATA>)){chomp$data;next unless$data =~ /^[FGHI]/;my ($func,@x)=split /,/,$data;my$c=$f{$func};$c =~ s/X(\d)/$x[$1]/g;$c =~ s/(S\d{2})/$s{$1}/;$c =~ s/^(.*)=rotate_left\((.*),(.*)\)\+(.*)$//;my$su=32 - $3;my$sh=(1 << $3)- 1;$c="$1=(((\$r=$2)<<$3)|((\$r>>$su)&$sh))+$4";$insert .= "\t$c\n"}close DATA;my$dump='
    sub round {
  	my ($a,$b,$c,$d) = @_[0 .. 3];
  	my $r;' .$insert .'
  	$_[0]+$a' .$MSK .', $_[1]+$b ' .$MSK .', $_[2]+$c' .$MSK .', $_[3]+$d' .$MSK .';
    }';eval$dump}gen_code();sub _encode_hex {unpack 'H*',$_[0]}sub _encode_base64 {my$res;while ($_[0]=~ /(.{1,45})/gs){$res .= substr pack('u',$1),1;chop$res}$res =~ tr|` -_|AA-Za-z0-9+/|;chop$res;chop$res;$res}sub new {my$proto=shift;my$class=ref$proto || $proto;my$self={};bless$self,$class;$self->reset();$self}sub reset {my$self=shift;delete$self->{_data};$self->{_state}=[A,B,C,D ];$self->{_length}=0;$self}sub add {my$self=shift;$self->{_data}.= join '',@_ if @_;my ($i,$c);for$i (0 .. (length$self->{_data})/ 64 - 1){my@X=unpack 'V16',substr$self->{_data},$i * 64,64;@{$self->{_state}}=round(@{$self->{_state}},@X);++$c}if ($c){substr($self->{_data},0,$c * 64)='';$self->{_length}+= $c * 64}$self}sub finalize {my$self=shift;$self->{_data}.= chr(128);my$l=$self->{_length}+ length$self->{_data};$self->{_data}.= "\0" x (($l % 64 <= 56 ? 56 : 120)- $l % 64);$l=($l - 1)* 8;$self->{_data}.= pack 'VV',$l & MAX,($l >> 16 >> 16);$self->add();$self}sub addfile {my ($self,$fh)=@_;if (!ref($fh)&& ref(\$fh)ne "GLOB"){require Symbol;$fh=Symbol::qualify($fh,scalar caller)}my$read=0;my$buffer='';$self->add($buffer)while$read=read$fh,$buffer,8192;die __PACKAGE__," read failed: $!" unless defined$read;$self}sub add_bits {my$self=shift;return$self->add(pack 'B*',shift)if @_==1;my ($b,$n)=@_;die __PACKAGE__," Invalid number of bits\n" if$n % 8;$self->add(substr$b,0,$n / 8)}sub digest {my$self=shift;$self->finalize();my$res=pack 'V4',@{$self->{_state}};$self->reset();$res}sub hexdigest {_encode_hex($_[0]->digest)}sub b64digest {_encode_base64($_[0]->digest)}sub clone {my$self=shift;my$clone={_state=>[@{$self->{_state}}],_length=>$self->{_length},_data=>$self->{_data}};bless$clone,ref$self || $self}sub md5 {my$message=padding(join '',@_);my ($a,$b,$c,$d)=(A,B,C,D);my$i;for$i (0 .. (length$message)/ 64 - 1){my@X=unpack 'V16',substr$message,$i * 64,64;($a,$b,$c,$d)=round($a,$b,$c,$d,@X)}pack 'V4',$a,$b,$c,$d}sub md5_hex {_encode_hex&md5}sub md5_base64 {_encode_base64&md5}1;__DATA__ FF,$a,$b,$c,$d,$_[4],7,0xd76aa478,/* 1 */
  FF,$d,$a,$b,$c,$_[5],12,0xe8c7b756,/* 2 */
  FF,$c,$d,$a,$b,$_[6],17,0x242070db,/* 3 */
  FF,$b,$c,$d,$a,$_[7],22,0xc1bdceee,/* 4 */
  FF,$a,$b,$c,$d,$_[8],7,0xf57c0faf,/* 5 */
  FF,$d,$a,$b,$c,$_[9],12,0x4787c62a,/* 6 */
  FF,$c,$d,$a,$b,$_[10],17,0xa8304613,/* 7 */
  FF,$b,$c,$d,$a,$_[11],22,0xfd469501,/* 8 */
  FF,$a,$b,$c,$d,$_[12],7,0x698098d8,/* 9 */
  FF,$d,$a,$b,$c,$_[13],12,0x8b44f7af,/* 10 */
  FF,$c,$d,$a,$b,$_[14],17,0xffff5bb1,/* 11 */
  FF,$b,$c,$d,$a,$_[15],22,0x895cd7be,/* 12 */
  FF,$a,$b,$c,$d,$_[16],7,0x6b901122,/* 13 */
  FF,$d,$a,$b,$c,$_[17],12,0xfd987193,/* 14 */
  FF,$c,$d,$a,$b,$_[18],17,0xa679438e,/* 15 */
  FF,$b,$c,$d,$a,$_[19],22,0x49b40821,/* 16 */ 
  GG,$a,$b,$c,$d,$_[5],5,0xf61e2562,/* 17 */
  GG,$d,$a,$b,$c,$_[10],9,0xc040b340,/* 18 */
  GG,$c,$d,$a,$b,$_[15],14,0x265e5a51,/* 19 */
  GG,$b,$c,$d,$a,$_[4],20,0xe9b6c7aa,/* 20 */
  GG,$a,$b,$c,$d,$_[9],5,0xd62f105d,/* 21 */
  GG,$d,$a,$b,$c,$_[14],9,0x2441453,/* 22 */
  GG,$c,$d,$a,$b,$_[19],14,0xd8a1e681,/* 23 */
  GG,$b,$c,$d,$a,$_[8],20,0xe7d3fbc8,/* 24 */
  GG,$a,$b,$c,$d,$_[13],5,0x21e1cde6,/* 25 */
  GG,$d,$a,$b,$c,$_[18],9,0xc33707d6,/* 26 */
  GG,$c,$d,$a,$b,$_[7],14,0xf4d50d87,/* 27 */
  GG,$b,$c,$d,$a,$_[12],20,0x455a14ed,/* 28 */
  GG,$a,$b,$c,$d,$_[17],5,0xa9e3e905,/* 29 */
  GG,$d,$a,$b,$c,$_[6],9,0xfcefa3f8,/* 30 */
  GG,$c,$d,$a,$b,$_[11],14,0x676f02d9,/* 31 */
  GG,$b,$c,$d,$a,$_[16],20,0x8d2a4c8a,/* 32 */
  HH,$a,$b,$c,$d,$_[9],4,0xfffa3942,/* 33 */
  HH,$d,$a,$b,$c,$_[12],11,0x8771f681,/* 34 */
  HH,$c,$d,$a,$b,$_[15],16,0x6d9d6122,/* 35 */
  HH,$b,$c,$d,$a,$_[18],23,0xfde5380c,/* 36 */
  HH,$a,$b,$c,$d,$_[5],4,0xa4beea44,/* 37 */
  HH,$d,$a,$b,$c,$_[8],11,0x4bdecfa9,/* 38 */
  HH,$c,$d,$a,$b,$_[11],16,0xf6bb4b60,/* 39 */
  HH,$b,$c,$d,$a,$_[14],23,0xbebfbc70,/* 40 */
  HH,$a,$b,$c,$d,$_[17],4,0x289b7ec6,/* 41 */
  HH,$d,$a,$b,$c,$_[4],11,0xeaa127fa,/* 42 */
  HH,$c,$d,$a,$b,$_[7],16,0xd4ef3085,/* 43 */
  HH,$b,$c,$d,$a,$_[10],23,0x4881d05,/* 44 */
  HH,$a,$b,$c,$d,$_[13],4,0xd9d4d039,/* 45 */
  HH,$d,$a,$b,$c,$_[16],11,0xe6db99e5,/* 46 */
  HH,$c,$d,$a,$b,$_[19],16,0x1fa27cf8,/* 47 */
  HH,$b,$c,$d,$a,$_[6],23,0xc4ac5665,/* 48 */
  II,$a,$b,$c,$d,$_[4],6,0xf4292244,/* 49 */
  II,$d,$a,$b,$c,$_[11],10,0x432aff97,/* 50 */
  II,$c,$d,$a,$b,$_[18],15,0xab9423a7,/* 51 */
  II,$b,$c,$d,$a,$_[9],21,0xfc93a039,/* 52 */
  II,$a,$b,$c,$d,$_[16],6,0x655b59c3,/* 53 */
  II,$d,$a,$b,$c,$_[7],10,0x8f0ccc92,/* 54 */
  II,$c,$d,$a,$b,$_[14],15,0xffeff47d,/* 55 */
  II,$b,$c,$d,$a,$_[5],21,0x85845dd1,/* 56 */
  II,$a,$b,$c,$d,$_[12],6,0x6fa87e4f,/* 57 */
  II,$d,$a,$b,$c,$_[19],10,0xfe2ce6e0,/* 58 */
  II,$c,$d,$a,$b,$_[10],15,0xa3014314,/* 59 */
  II,$b,$c,$d,$a,$_[17],21,0x4e0811a1,/* 60 */
  II,$a,$b,$c,$d,$_[8],6,0xf7537e82,/* 61 */
  II,$d,$a,$b,$c,$_[15],10,0xbd3af235,/* 62 */
  II,$c,$d,$a,$b,$_[6],15,0x2ad7d2bb,/* 63 */
  II,$b,$c,$d,$a,$_[13],21,0xeb86d391,/* 64 */
DIGEST_PERL_MD5

    $fatpacked{"Exporter.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'EXPORTER';
  package Exporter;require 5.006;our$Debug=0;our$ExportLevel=0;our$Verbose ||= 0;our$VERSION='5.74';our (%Cache);sub as_heavy {require Exporter::Heavy;my$c=(caller(1))[3];$c =~ s/.*:://;\&{"Exporter::Heavy::heavy_$c"}}sub export {goto &{as_heavy()}}sub import {my$pkg=shift;my$callpkg=caller($ExportLevel);if ($pkg eq "Exporter" and @_ and $_[0]eq "import"){*{$callpkg."::import"}=\&import;return}my$exports=\@{"$pkg\::EXPORT"};my$fail=${$pkg .'::'}{EXPORT_FAIL}&& \@{"$pkg\::EXPORT_FAIL"};return export$pkg,$callpkg,@_ if$Verbose or $Debug or $fail && @$fail > 1;my$export_cache=($Cache{$pkg}||= {});my$args=@_ or @_=@$exports;if ($args and not %$export_cache){s/^&//,$export_cache->{$_}=1 foreach (@$exports,@{"$pkg\::EXPORT_OK"})}my$heavy;if ($args or $fail){($heavy=(/\W/ or $args and not exists$export_cache->{$_}or $fail and @$fail and $_ eq $fail->[0]))and last foreach (@_)}else {($heavy=/\W/)and last foreach (@_)}return export$pkg,$callpkg,($args ? @_ : ())if$heavy;local$SIG{__WARN__}=sub {require Carp;&Carp::carp}if not $SIG{__WARN__};*{"$callpkg\::$_"}=\&{"$pkg\::$_"}foreach @_}sub export_fail {my$self=shift;@_}sub export_to_level {goto &{as_heavy()}}sub export_tags {goto &{as_heavy()}}sub export_ok_tags {goto &{as_heavy()}}sub require_version {goto &{as_heavy()}}1;
EXPORTER

    $fatpacked{"Exporter/Heavy.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'EXPORTER_HEAVY';
  package Exporter::Heavy;use strict;no strict 'refs';require Exporter;our$VERSION=$Exporter::VERSION;sub _rebuild_cache {my ($pkg,$exports,$cache)=@_;s/^&// foreach @$exports;@{$cache}{@$exports}=(1)x @$exports;my$ok=\@{"${pkg}::EXPORT_OK"};if (@$ok){s/^&// foreach @$ok;@{$cache}{@$ok}=(1)x @$ok}}sub heavy_export {my$oldwarn=$SIG{__WARN__};local$SIG{__WARN__}=sub {local$SIG{__WARN__}=$oldwarn;my$text=shift;if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//){require Carp;local$Carp::CarpLevel=1;Carp::carp($text)}else {warn$text}};local$SIG{__DIE__}=sub {require Carp;local$Carp::CarpLevel=1;Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")if $_[0]=~ /^Unable to create sub named "(.*?)::"/};my($pkg,$callpkg,@imports)=@_;my($type,$sym,$cache_is_current,$oops);my($exports,$export_cache)=(\@{"${pkg}::EXPORT"},$Exporter::Cache{$pkg}||= {});if (@imports){if (!%$export_cache){_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (grep m{^[/!:]},@imports){my$tagsref=\%{"${pkg}::EXPORT_TAGS"};my$tagdata;my%imports;my($remove,$spec,@names,@allexports);unshift@imports,':DEFAULT' if$imports[0]=~ m/^!/;for$spec (@imports){$remove=$spec =~ s/^!//;if ($spec =~ s/^://){if ($spec eq 'DEFAULT'){@names=@$exports}elsif ($tagdata=$tagsref->{$spec}){@names=@$tagdata}else {warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];++$oops;next}}elsif ($spec =~ m:^/(.*)/$:){my$patn=$1;@allexports=keys %$export_cache unless@allexports;@names=grep(/$patn/,@allexports)}else {@names=($spec)}warn "Import ".($remove ? "del":"add").": @names " if$Exporter::Verbose;if ($remove){for$sym (@names){delete$imports{$sym}}}else {@imports{@names}=(1)x @names}}@imports=keys%imports}my@carp;for$sym (@imports){if (!$export_cache->{$sym}){if ($sym =~ m/^\d/){$pkg->VERSION($sym);if (@imports==1){@imports=@$exports;last}if (@imports==2 and!$imports[1]){@imports=();last}}elsif ($sym !~ s/^&// ||!$export_cache->{$sym}){unless ($cache_is_current){%$export_cache=();_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (!$export_cache->{$sym}){push@carp,qq["$sym" is not exported by the $pkg module];$oops++}}}}if ($oops){require Carp;Carp::croak(join("\n",@carp,"Can't continue after import errors"))}}else {@imports=@$exports}my($fail,$fail_cache)=(\@{"${pkg}::EXPORT_FAIL"},$Exporter::FailCache{$pkg}||= {});if (@$fail){if (!%$fail_cache){my@expanded=map {/^\w/ ? ($_,'&'.$_): $_}@$fail;warn "${pkg}::EXPORT_FAIL cached: @expanded" if$Exporter::Verbose;@{$fail_cache}{@expanded}=(1)x @expanded}my@failed;for$sym (@imports){push(@failed,$sym)if$fail_cache->{$sym}}if (@failed){@failed=$pkg->export_fail(@failed);for$sym (@failed){require Carp;Carp::carp(qq["$sym" is not implemented by the $pkg module ],"on this architecture")}if (@failed){require Carp;Carp::croak("Can't continue after import errors")}}}warn "Importing into $callpkg from $pkg: ",join(", ",sort@imports)if$Exporter::Verbose;for$sym (@imports){(*{"${callpkg}::$sym"}=\&{"${pkg}::$sym"},next)unless$sym =~ s/^(\W)//;$type=$1;no warnings 'once';*{"${callpkg}::$sym"}=$type eq '&' ? \&{"${pkg}::$sym"}: $type eq '$' ? \${"${pkg}::$sym"}: $type eq '@' ? \@{"${pkg}::$sym"}: $type eq '%' ? \%{"${pkg}::$sym"}: $type eq '*' ? *{"${pkg}::$sym"}: do {require Carp;Carp::croak("Can't export symbol: $type$sym")}}}sub heavy_export_to_level {my$pkg=shift;my$level=shift;(undef)=shift;my$callpkg=caller($level);$pkg->export($callpkg,@_)}sub _push_tags {my($pkg,$var,$syms)=@_;my@nontag=();my$export_tags=\%{"${pkg}::EXPORT_TAGS"};push(@{"${pkg}::$var"},map {$export_tags->{$_}? @{$export_tags->{$_}}: scalar(push(@nontag,$_),$_)}(@$syms)? @$syms : keys %$export_tags);if (@nontag and $^W){require Carp;Carp::carp(join(", ",@nontag)." are not tags of $pkg")}}sub heavy_require_version {my($self,$wanted)=@_;my$pkg=ref$self || $self;return ${pkg}->VERSION($wanted)}sub heavy_export_tags {_push_tags((caller)[0],"EXPORT",\@_)}sub heavy_export_ok_tags {_push_tags((caller)[0],"EXPORT_OK",\@_)}1;
EXPORTER_HEAVY

    $fatpacked{"File/Which.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'FILE_WHICH';
  package File::Which;use strict;use warnings;use Exporter ();use File::Spec ();our$VERSION='1.23';our@ISA='Exporter';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if ($^O eq 'MSWin32'){@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base .$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1 .. $#PATHEXT ])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

    $fatpacked{"File/pushd.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

    $fatpacked{"HTTP/Tinyish.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.15';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my ($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my ($self,$url)=@_;my ($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my ($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

    $fatpacked{"HTTP/Tinyish/Base.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my ($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if (/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my ($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my ($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

    $fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version' ],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my ($class,%attr)=@_;bless \%attr,$class}sub request {my ($self,$method,$url,$opts)=@_;$opts ||= {};my (undef,$temp)=File::Temp::tempfile(UNLINK=>1);my ($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my ($self,$url,$file,$opts)=@_;$opts ||= {};my (undef,$temp)=File::Temp::tempfile(UNLINK=>1);my ($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my ($self,$url,$opts)=@_;my@options=('--location','--silent','--max-time',($self->{timeout}|| 60),'--max-redirs',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my ($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

    $fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my ($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

    $fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my ($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my ($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field }=$hdrs->header($field)}\%headers}sub request {my ($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my ($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my ($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(delete$attr{max_redirect}|| 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my ($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

    $fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_ ],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my (undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my ($class,%attr)=@_;bless \%attr,$class}sub request {my ($self,$method,$url,$opts)=@_;$opts ||= {};my ($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my ($self,$url,$file,$opts)=@_;$opts ||= {};my ($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file ],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my ($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my ($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

    $fatpacked{"IPC/Run3.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

    $fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_},$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

    $fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_},$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

    $fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_},$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

    $fatpacked{"IPC/Run3/ProfPP.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

    $fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_},$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time) }=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

    $fatpacked{"JSON/PP.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'JSON_PP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::PP::ISA=('Exporter')}use overload ();use JSON::PP::Boolean;use Carp ();$JSON::PP::VERSION='4.04';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true;return ($false,$true)}else {delete$self->{false};delete$self->{true};return}}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($props->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){if (!$relaxed or $ch ne "\t"){$at--;decode_error('invalid character encountered while parsing JSON string')}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::PP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> 0x20){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20"){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_PP

    $fatpacked{"JSON/PP/Boolean.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::PP::Boolean::VERSION='4.04';1;
JSON_PP_BOOLEAN

    $fatpacked{"Simple/Accessor.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'SIMPLE_ACCESSOR';
  package Simple::Accessor;$Simple::Accessor::VERSION='1.13';use strict;use warnings;my$INFO;sub import {my ($class,@attr)=@_;my$from=caller();$INFO={}unless defined$INFO;$INFO->{$from}={}unless defined$INFO->{$from};$INFO->{$from}->{'attributes'}=[@attr];_add_with($from);_add_new($from);_add_accessors(to=>$from,attributes=>\@attr);return}sub _add_with {my$class=shift;return unless$class;my$with=$class .'::with';{no strict 'refs';*$with=sub {my (@what)=@_;$INFO->{$class}->{'with'}=[]unless$INFO->{$class}->{'with'};push @{$INFO->{$class}->{'with'}},@what;for my$module (@what){eval qq[require $module; 1] or die $@;_add_accessors(to=>$class,attributes=>$INFO->{$module}->{attributes},from_role=>$module)}return}}}sub _add_new {my$class=shift;return unless$class;my$new=$class .'::new';{no strict 'refs';*$new=sub {my ($class,%opts)=@_;my$self=bless {},$class;map {eval {$self->$_($opts{$_})}}keys%opts;if ($self->can('_before_build')){$self->_before_build(%opts)}for my$init ('build','initialize'){if ($self->can($init)){return unless$self->$init(%opts)}}if ($self->can('_after_build')){$self->_after_build(%opts)}return$self}}}sub _add_accessors {my (%opts)=@_;return unless my$class=$opts{to};my@attributes=@{$opts{attributes}};return unless@attributes;my$from_role=$opts{from_role};for my$att (@attributes){my$accessor=$class ."::" .$att;die "$class: attribute '$att' is already defined." if$class->can($att);no strict 'refs';*$accessor=sub {my ($self,$v)=@_;if (defined$v){for (qw{before validate set after}){if ($_ eq 'set'){$self->{$att}=$v;next}my$sub='_' .$_ .'_' .$att;if ($self->can($sub)){return unless$self->$sub($v)}elsif ($from_role){if (my$code=$from_role->can($sub)){return unless$code->($self,$v)}}}}elsif (!defined$self->{$att}){for my$builder (qw{build initialize}){my$sub='_' .$builder .'_' .$att;if ($self->can($sub)){return$self->{$att}=$self->$sub()}elsif ($from_role){if (my$code=$from_role->can($sub)){return$self->{$att}=$code->($self)}}}}return$self->{$att}}}@attributes=()}1;
SIMPLE_ACCESSOR

    $fatpacked{"parent.pm"} = '#line ' . ( 1 + __LINE__ ) . ' "' . __FILE__ . "\"\n" . <<'PARENT';
  package parent;use strict;our$VERSION='0.238';sub import {my$class=shift;my$inheritor=caller(0);if (@_ and $_[0]eq '-norequire'){shift @_}else {for (my@filename=@_){s{::|'}{/}g;require "$_.pm"}}{no strict 'refs';push @{"$inheritor\::ISA"},@_}}1;
PARENT

    s/^  //mg for values %fatpacked;

    my $class = 'FatPacked::' . ( 0 + \%fatpacked );
    no strict 'refs';
    *{"${class}::files"} = sub { keys %{ $_[0] } };

    if ( $] < 5.008 ) {
        *{"${class}::INC"} = sub {
            if ( my $fat = $_[0]{ $_[1] } ) {
                my $pos  = 0;
                my $last = length $fat;
                return (
                    sub {
                        return 0 if $pos == $last;
                        my $next = ( 1 + index $fat, "\n", $pos ) || $last;
                        $_ .= substr $fat, $pos, $next - $pos;
                        $pos = $next;
                        return 1;
                    }
                );
            }
        };
    }

    else {
        *{"${class}::INC"} = sub {
            if ( my $fat = $_[0]{ $_[1] } ) {
                open my $fh, '<', \$fat
                  or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
                return $fh;
            }
            return;
        };
    }

    unshift @INC, bless \%fatpacked, $class;
}    # END OF FATPACK CODE

use strict;
use warnings;

use App::cplay::cli ();

unless (caller) {
    exit( App::cplay::cli->new( name => "App::cplay" )->run(@ARGV) // 0 );
}

1;

### DO NOT EDIT POD HERE, adjuts cplay.pm
## __CPLAY_POD_MARKER__

=encoding utf8

=head1 NAME

App::cplay -  CPAN client using pause-play indexes

=head1 SYNOPSIS

    # Install one ore more distribution [using module or distribution names]
    cplay Cwd
    cplay Cwd File::Copy

    cplay install Cwd
    cplay install Cwd File::Copy

    cplay install --verbose Cwd  # more output
    cplay install --debug Cwd    # additional debug informations

    # install a specific version or trial version
    cplay install Devel-PPPort@3.57
    cplay install Devel-PPPort@3.57_02

    # preserve .cpbuild directory to preserve cache and debug
    cplay install --no-cleanup --verbose A1z::Html

    # install distributions from a cpanfile
    cplay cpanfile .
    cplay cpanfile ~/my-custom.cpanfile

    # Getting a repository / distribution name for a module
    cplay get-repo Simple::Accessor

    cplay --version
    cplay --help

Run C<cplay -h> or C<perldoc cplay> for more options.

=head1 DESCRIPTION

This repository provides the `cplay` client to install Perl modules without using PAUSE.
This is using the `pause-play` GitHub repositories indexed by `pause-index`

L<https://ix.cplay.us|https://ix.cplay.us>

Rather than using distribution tarball from PAUSE itself, `play` is relying on GitHub infrastructure to download distributions.

The repo `pause-index` host some index files which can be consumed to download and install most Perl modules.

`cplay` is the recommended CPAN client using these indexes and GitHub repositories.
You can read more about cplay client on the L<cplay website cplay.us|https://cplay.us>.

=head1 INSTALLATION

=head2 Installing to system perl

This is using cplay to install itself.

    curl -sL https://git.io/cplay | perl - self-install
    cplay --version

Or if you are not using root

    sudo curl -sL https://git.io/cplay | perl - self-install

You can also select where you want to install the script using installdirs

    curl -sL https://git.io/cplay | perl - self-install --installdirs=site  # this is the default
    curl -sL https://git.io/cplay | perl - self-install --installdirs=perl
    curl -sL https://git.io/cplay | perl - self-install --installdirs=vendor


=head2 Local installation

You can also download and install cplay to any custom location.

   curl -fsSL --compressed http://get.cplay.us > cplay
   chmod +x cplay
   ./cplay --version

=head1 How to use cplay

=head2 Install a Perl Module

   # install a single module
   cplay A1z::Html
   cplay install A1z::Html
   cplay install --verbose A1z::Html

   # install multiple modules
   cplay First::Module Second::Module ...

=head2 Install a Perl distribution

You could use either a module name or a distribution name.

   # install a single distribution
   cplay A1z-Html
   cplay install A1z-Html
   cplay install --verbose A1z-Html

   # install multiple modules
   cplay First-Distribution Second-Distribution

   # install a custom version
   cplay A1z-Html@0.04

   # install a trial version
   cplay Devel-PPPort@3.57_02

=head2 Mix Perl modules and distributions

   cplay Module::Name Distribution-Name ...

=head2 Install Perl Modules from a cpanfile

    # by default use ./cpanfile
    cplay cpanfile
    cplay cpanfile .
    cplay cpanfile ~/cpanfile.custom

    # use one or more cpanfiles
    cplay cpanfile ~/cpanfile.1 ~/cpanfile.2 ...

    # set some feature with cpanfile
    cplay cpanfile --feature one --feature two

    # set some types/phases
    cplay cpanfile --with-requires --with-build --with-runtime --with-test

    # shortcut to enable all
    cplay cpanfile --with-all


=head2 Install a development or TRIAL version

   # install a trial version
   cplay Devel-PPPort@3.57_02

=head2 Install a module from a custom repository

   cplay --from-tarball ./path-to/custom.tar.gz
   # where :owner, :repository and :sha are replaced with the accurate values
   cplay --from-tarball https://github.com/:owner/:repository/archive/:sha.tar.gz

   cplay --from-tarball -d https://github.com/pause-play/A1z-Html/archive/p5.tar.gz

=head2 Install one distribution to a custom directory

By default modules are install to the current @INC, but you can specify a custom directory
where to install these modules using -L.

   cplay -L ~/vendor Simple-Accessor

=head2 Set destination

You can setup the installdir destination you are targetting.
Possible values are: perl, site, vendor (default: site)

                                   INSTALLDIRS set to
                             perl        site          vendor

                   PERLPREFIX      SITEPREFIX          VENDORPREFIX
    INST_ARCHLIB   INSTALLARCHLIB  INSTALLSITEARCH     INSTALLVENDORARCH
    INST_LIB       INSTALLPRIVLIB  INSTALLSITELIB      INSTALLVENDORLIB
    INST_BIN       INSTALLBIN      INSTALLSITEBIN      INSTALLVENDORBIN
    INST_SCRIPT    INSTALLSCRIPT   INSTALLSITESCRIPT   INSTALLVENDORSCRIPT
    INST_MAN1DIR   INSTALLMAN1DIR  INSTALLSITEMAN1DIR  INSTALLVENDORMAN1DIR
    INST_MAN3DIR   INSTALLMAN3DIR  INSTALLSITEMAN3DIR  INSTALLVENDORMAN3DIR

Sample usages:

    cplay install A1z-Html                     # install to site directories by default
    cplay install --installdir=site   A1z-Html  # site is the default
    cplay install --installdir=vendor A1z-Html
    cplay install --installdir=perl   A1z-Html

=head2 Checking a repository

This will clone and open a SHELL in a temporary directory,
removed once you exit the session.

  cplay look A1z::Html
  cplay look A1z-Html

=head1 USAGE

  cplay [ACTION] [OPTIONS] [ARGS]

=head2 ACTIONS

      install             default action to install distributions
      cpanfile            install dependencies from a cpanfile
      fromtarabll         install a distribution from a tarball
      selfupdate          selfupdate cplay binary
      selfinstall         selfinstall the binary
      help                display this documentation
      look                Clones & opens the distribution with your SHELL

=head2 OPTIONS

=head2 Generic options

       --no-cleanup         preserve the .cpbuild directory
   -v, --verbose            Turns on chatty output
   -d, --debug              enable --verbose and display some additional informations
       --show-progress --no-show-progress
                            show progress, default: on
       --refresh            force refresh the index files
       --color, --no-color  turn on/off color output, default: on
       --test               run test cases, default: on
   -n, --no-test
       --reinstall          reinstall the distribution(s)/module(s) even if you already have the latest version installed
                            do not apply to dependencies
       --cache-dir, --cache specify an alternate cache directory (default: ~/.cplay)
       --no-check-signature disable signature check (default: on)

       --configure-timeout  Timeout for configuring a distibution  (default: 60)
       --build-timeout      Timeout for building a distribution    (default: 3600)
       --test-timeout       Timeout for running tests              (default: 1800)
       --install-timeout    Timeout forinstalling files            (default: 60)
       use a value of '0' to disable a timeout
   -L, --local-lib DIR      Specify the install base directory to install all modules.
       --installdir TYPE    Set installation destination, possible values are perl, site, vendor (default:site)

=head2 cpanfile options

       --feature=identifier
         specify the feature to enable in cpanfile; you can use --feature multiple times
       --with-requires,   --without-requires   (default: with)
       --with-recommends, --without-recommends (default: without)
       --with-suggests,   --without-suggests   (default: without)
       --with-configure,  --without-configure  (default: without)
       --with-build,      --without-build      (default: with)
       --with-test,       --without-test       (default: with)
       --with-runtime,    --without-runtime    (default: with)
       --with-develop,    --without-develop    (default: without)
       --with-all         shortcut for
                          --with-requires --with-recommends --with-suggests \
                          --with-configure --with-build --with-test --with-runtime --with-develop
         specify types/phases of dependencies in cpanfile to be installed


